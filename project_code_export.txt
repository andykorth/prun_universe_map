

--- FILE: README.md ---

# Taiyi's Prosperous Universe Map
An interactive, data-rich visualization of the Prosperous Universe game world. 
This project provides a user-friendly interface for exploring star systems, planets, and their resources, 
with features including:

Interactive SVG-based map of the game universe
Detailed information panels for each star system and planet
Pathfinding functionality to plot routes between systems
Visual indicators for planet tiers and available facilities
Integration with game data for up-to-date information on resources and COGC programs
React-based UI with D3.js for smooth interactions and animations

Perfect for players looking to plan their interstellar trade routes or for those curious about the vast 
Prosperous Universe game world. Contributions welcome!

### Tech Stack:

* React
* D3.js
* SVG
* Tailwind CSS

### Updating the PRUN data:

* Replace `public/prun_universe_data.json` with the contents from the FIO endpoint: https://rest.fnar.net/systemstars
* Replace `public/planet_data.json` with the contents of: https://rest.fnar.net/planet/allplanets/full
* Run the python script 

### Getting Started with Create React App

This project was bootstrapped with [Create React App](https://github.com/facebook/create-react-app).

### Available Scripts

In the project directory, you can run:

#### `npm start`

Runs the app in the development mode.\
Open [http://localhost:3000](http://localhost:3000) to view it in your browser.

The page will reload when you make changes.\
You may also see any lint errors in the console.

#### `npm test`

Launches the test runner in the interactive watch mode.\
See the section about [running tests](https://facebook.github.io/create-react-app/docs/running-tests) for more information.

#### `npm run build`

Builds the app for production to the `build` folder.\
It correctly bundles React in production mode and optimizes the build for the best performance.

The build is minified and the filenames include the hashes.\
Your app is ready to be deployed!

See the section about [deployment](https://facebook.github.io/create-react-app/docs/deployment) for more information.

#### `npm run eject`

**Note: this is a one-way operation. Once you `eject`, you can't go back!**

If you aren't satisfied with the build tool and configuration choices, you can `eject` at any time. This command will remove the single build dependency from your project.

Instead, it will copy all the configuration files and the transitive dependencies (webpack, Babel, ESLint, etc) right into your project so you have full control over them. All of the commands except `eject` will still work, but they will point to the copied scripts so you can tweak them. At this point you're on your own.

You don't have to ever use `eject`. The curated feature set is suitable for small and middle deployments, and you shouldn't feel obligated to use this feature. However we understand that this tool wouldn't be useful if you couldn't customize it when you are ready for it.

### Learn More

You can learn more in the [Create React App documentation](https://facebook.github.io/create-react-app/docs/getting-started).

To learn React, check out the [React documentation](https://reactjs.org/).

#### Code Splitting

This section has moved here: [https://facebook.github.io/create-react-app/docs/code-splitting](https://facebook.github.io/create-react-app/docs/code-splitting)

#### Analyzing the Bundle Size

This section has moved here: [https://facebook.github.io/create-react-app/docs/analyzing-the-bundle-size](https://facebook.github.io/create-react-app/docs/analyzing-the-bundle-size)

#### Making a Progressive Web App

This section has moved here: [https://facebook.github.io/create-react-app/docs/making-a-progressive-web-app](https://facebook.github.io/create-react-app/docs/making-a-progressive-web-app)

#### Advanced Configuration

This section has moved here: [https://facebook.github.io/create-react-app/docs/advanced-configuration](https://facebook.github.io/create-react-app/docs/advanced-configuration)

#### Deployment

This section has moved here: [https://facebook.github.io/create-react-app/docs/deployment](https://facebook.github.io/create-react-app/docs/deployment)

#### `npm run build` fails to minify

This section has moved here: [https://facebook.github.io/create-react-app/docs/troubleshooting#npm-run-build-fails-to-minify](https://facebook.github.io/create-react-app/docs/troubleshooting#npm-run-build-fails-to-minify)


--- FILE: src/App.css ---

/* App.css */

body {
  background-color: #222222;
  margin: 0;
  font-family: Arial, sans-serif;
}

.App {
  display: flex;
  flex-direction: column;
  height: 100vh;
  color: white;
}

.App-header {
  display: flex;
  flex-wrap: wrap;
  justify-content: space-between;
  align-items: center;
  padding: 10px;
  background-color: #222222;
}

.header-right {
    flex-direction: column;
}

.header-left, .header-center, .header-right {
  display: flex;
  align-items: center;
  flex: 1 1 auto;
  margin-bottom: 2px;
}

.header-center {
  justify-content: start;
}

.header-right {
  align-items: end;
  justify-content: center;
  flex-wrap: wrap;
}

.header-info {
  display: flex;
  flex: 0 1 auto;
  margin-bottom: 2px;
  flex-flow: row wrap;
  align-items: start;
  justify-content: center;
}

.header-buttons {
  display: flex;
  flex: 0 1 auto;
  margin-bottom: 2px;
  flex-flow: row wrap;
  flex-direction: column;
  align-items: center;
  justify-content: center;
}

.material-search-field,
.search-field,
.clear-button,
.pathfinding-toggle-container {
  margin: 5px;
}

.toggle-stack-container {
  display: flex;
  flex-direction: column;
  gap: 0px;
  position: relative;
}

.App-logo {
  width: 50px;
  height: 50px;
  margin-right: 10px;
  border-radius: 50%;
}

.App-header h1 {
  font-size: 18px;
  margin: 0;
  white-space: nowrap;
}

.filter-toggle {
  background-color: #f7a600;
  border: none;
  color: white;
  padding: 5px 10px;
  cursor: pointer;
  border-radius: 4px;
  margin-right: 10px;
}

.filter-categories {
  display: flex;
  justify-content: space-around;
  flex-wrap: wrap;
}

.filter-category {
  margin: 0 10px;
}

.filter-category h4 {
  margin: 0 0 5px 0;
  color: #f7a600;
  font-size: 14px;
}

.checkbox-group {
  display: flex;
  flex-direction: column;
}

.checkbox-label {
  position: relative;
  display: flex;
  align-items: center;
  margin-bottom: 3px;
  color: #fff;
  font-size: 12px;
}

.checkbox-label input {
  margin-right: 5px;
}

.material-search-field input,
.search-field input {
  padding: 5px 10px;
  border: 1px solid #ccc;
  border-radius: 4px 0 0 4px;
  background-color: #333;
  color: #fff;
  margin-left: 5px;
}

.search-controls button {
  padding: 5px 10px;
  background-color: #f7a600;
  border: none;
  color: white;
  cursor: pointer;
  border-radius: 4px;
  margin-right: 5px;
}

.main-content {
  display: flex;
  flex: 1;
  overflow: hidden;
  position: relative;
}

#map-container {
  flex: 1;
  overflow: hidden;
  position: relative;
}

.sidebar {
  width: max(20%, 250px);
  background-color: #333333;
  transition: width 0.3s ease;
  position: relative;
  z-index: 10;
}

.sidebar.collapsed {
  width: 20px;
}

.toggle-btn {
  position: absolute;
  top: 10px;
  left: -30px;
  background-color: #444444;
  border: none;
  color: white;
  padding: 5px;
  cursor: pointer;
}

.sidebar-content {
  padding: 20px;
  padding-bottom: 20px;
  overflow-y: auto;
  height: 100%;
  box-sizing: border-box;
}

.sidebar-content svg {
  display: inline-block;
  vertical-align: middle;
  width: 18px;
  height: 18px;
}

.planet-info-sb {
  margin-bottom: 20px;
}

.sidebar .planet-id-link {
  color: #FFC107;            /* amber/gold */
  text-decoration: none;
}

.sidebar .planet-id-link:visited {
  color: #FFB300;
}

.sidebar .planet-id-link:hover {
  color: #FFECB3;            /* pale gold */
  text-decoration: underline;
}

.sidebar .planet-id-link:focus,
.sidebar .planet-id-link:active {
  outline: 2px solid #FFECB3;
  outline-offset: 2px;
}

.resource-item-sb {
  display: flex;
  align-items: center;
  margin-bottom: 5px;
}

.concentration-bar-container-sb {
  width: 100px;
  background-color: #ddd;
  height: 10px;
  margin-left: 5px;
}

.concentration-bar-sb {
  height: 100%;
  transition: width 0.3s ease;
}

.resource-percentage {
  display: inline-block;
  min-width: 50px;
  text-align: right;
  margin-left: 5px;
}

.pathfinding-toggle {
  display: flex;
  align-items: center;
  cursor: pointer;
  font-size: 12px;
}

.pathfinding-toggle .toggle-token {
  margin: 0px;
  margin-right: 8px;
}

.pathfinding-toggle .toggle-token::before {
  content: "Pathfinding";
}

.meteor-density-toggle .toggle-token::before {
  content: "Data Overlay";
}

.info-tooltip-container {
  margin-top: 5px;
  margin-left: 5px;
  margin-right: 5px;
}

.tooltip {
  font-size: 12px;
  line-height: 1.4;
}

.tooltip h4 {
  font-size: 14px;
  margin-bottom: 8px;
}

.tooltip ul {
  margin: 0;
  padding: 0;
  list-style-type: none;
}

.tooltip li {
  margin-bottom: 4px;
}

.search-highlight {
  transform-box: fill-box;
  transform-origin: center;
}

search-container {
  display: flex;
  align-items: center;
  margin-right: 10px;
}

.search-button {
  background-color: #f7a600;
  border: none;
  color: white;
  padding: 6px 5px;
  cursor: pointer;
  border-radius: 0 4px 4px 0;
}

.search-notification {
  position: fixed;
  top: 85px;
  left: 50%;
  transform: translateX(-50%);
  background-color: rgba(0, 0, 0, 0.8);
  color: white;
  padding: 10px 20px;
  border-radius: 5px;
  z-index: 1000;
  animation: fadeInOut 3s ease-in-out;
}

@keyframes fadeInOut {
  0%, 100% { opacity: 0; }
  10%, 90% { opacity: 1; }
}

.clear-button {
  background-color: #6c757d;
  border: none;
  color: white;
  padding: 6px 10px;
  cursor: pointer;
  border-radius: 4px;
  margin-right: 10px;
  margin-left: 5px;
}

.checkbox-label:hover::after {
  content: attr(data-tooltip);
  position: absolute;
  background-color: #333;
  color: #fff;
  padding: 5px;
  border-radius: 4px;
  font-size: 12px;
  white-space: nowrap;
  z-index: 1000;
  bottom: 0;
  left: -15px;
  transform: translateX(-50%);
}

.planet-condition-icon {
  position: relative;
  display: inline-block;
  margin-left: 5px;
  cursor: help;
}

.planet-condition-icon .tooltip {
  position: absolute;
  top: 100%;
  left: 50%;
  transform: translateX(-50%);
  background: #333;
  color: #fff;
  padding: 5px;
  border-radius: 3px;
  font-size: 12px;
  white-space: nowrap;
  z-index: 1000;
  pointer-events: none;
}

.company-base-indicator {
  background-color: #f7a600;
  color: white;
  padding: 2px 5px;
  border-radius: 3px;
  font-size: 12px;
  margin-top: 5px;
  display: inline-block;
}

.planet-info-sb.highlighted {
  border-left: 3px solid #f7a600;
  padding-left: 5px;
}

.company-search-toggle {
  margin-top: 5px;
  margin-bottom: 5px;
}

/* Adjusted css for small screen sizes */

@media (max-width: 820px) {
  .App-header {
    flex-wrap: wrap;
    justify-content: center;
    padding: 5px;
  }

  .header-left {
    display: none; /* This hides the logo and title */
  }

  .header-right, .header-info .header-buttons {
    flex-direction: column;
  }

  .header-left, .header-center, .header-right, .header-info .header-buttons {
    flex: 0 1 auto;
  }

  .filter-toggle {
    padding: 3px 6px;
    font-size: 12px;
  }

  .filter-categories {
    flex-direction: row;
    flex-wrap: wrap;
    justify-content: center;
  }

  .filter-category {
    margin: 3px;
  }

  .filter-category h4 {
    font-size: 11px;
  }

  .checkbox-label {
    font-size: 10px;
  }

  .material-search-field input,
  .search-field input {
    padding: 3px 5px;
    font-size: 12px;
  }

  .search-button {
    padding: 4px 5px;
    font-size: 12px;
  }

  .clear-button {
    padding: 4px 5px;
    font-size: 12px;
    margin-right: 5px;
    margin-bottom: 10px;
  }

  .info-tooltip-container {
    margin-top: 0px;
    margin-left: 5px;
  }

  .pathfinding-toggle .toggle-token::before {
    content: "Path";
  }

  .meteor-density-toggle .toggle-token::before {
    content: "Data";
  }

  .sidebar {
    width: max(20%, 250px);
  }

  .sidebar.collapsed {
    width: 10px;
  }

  .sidebar-content {
    padding: 10px;
    padding-bottom: 5px;
  }

  .sidebar-content h3 {
    font-size: 16px;
  }

  .sidebar-content h2 {
    font-size: 22px;
  }

  .sidebar-content svg {
    width: 18px;
    height: 18px;
  }

  .resource-item-sb {
    font-size: 14px;
  }
}

.header-center {
  flex: 2; /* Allow center to take up available space */
  display: flex;
  justify-content: center;
  align-items: center;
  padding: 0 10px;
}

.header-right {
  flex: 1;
  display: flex;
  justify-content: flex-end;
}

/* Standard Controls Styles */
.standard-controls {
  display: flex;
  flex-direction: column;
  width: 100%;
  align-items: center;
}

.controls-row {
  display: flex;
  align-items: center;
  justify-content: center;
  width: 100%;
  gap: 10px;
}

.search-group {
    display: flex;
}

.button-group {
    display: flex;
}


/* Gateway Controls Styles */
.gateway-controls {
    display: flex;
    gap: 15px;
    align-items: center;
}

.strategy-toggle {
    display: flex;
    background: #333;
    border-radius: 15px;
    padding: 2px;
}

/* Global Tools Right Side */
.global-tools {
    display: flex;
    align-items: center;
    gap: 8px;
}

.mode-switch-btn {
    font-weight: bold;
    border: 1px solid #f7a600;
}

.tool-separator {
    width: 1px;
    height: 24px;
    background: #444;
    margin: 0 5px;
}

.mini-stack {
    display: flex;
    flex-direction: column;
    gap: 2px;
}

/* Sidebar Gateway Styles */
.gateway-legend .legend-items {
    display: flex;
    flex-wrap: wrap;
    gap: 10px;
    margin-bottom: 15px;
}

.legend-item {
    display: flex;
    align-items: center;
    font-size: 11px;
    color: #ccc;
}

.color-box {
    width: 12px;
    height: 12px;
    margin-right: 5px;
    border-radius: 2px;
}

.planned-gateway-item {
    display: flex;
    justify-content: space-between;
    align-items: center;
    background: #333;
    padding: 5px 8px;
    margin-bottom: 4px;
    border-radius: 4px;
    font-size: 12px;
}

.delete-gw-btn {
    background: none;
    border: none;
    color: #666;
    cursor: pointer;
    padding: 2px;
    display: flex;
}

.delete-gw-btn:hover {
    color: #f54c4c;
}

.placeholder-text {
    color: #666;
    font-style: italic;
    font-size: 12px;
    text-align: center;
    padding: 20px 0;
}

--- FILE: src/App.js ---

import React, { useState } from 'react';
import UniverseMap from './components/UniverseMap';
import Sidebar from './components/Sidebar';
import PathfindingToggle from './components/PathfindingToggle';
import MeteorDensityToggle from './components/MeteorDensityToggle';
import InfoTooltip from './components/InfoTooltip';
import StandardControls from './components/StandardControls';
import GatewayControls from './components/GatewayControls';
import { GraphProvider } from './contexts/GraphContext';
import { SelectionProvider } from './contexts/SelectionContext';
import { SearchProvider } from './contexts/SearchContext';
import { CogcOverlayProvider } from './contexts/CogcOverlayContext';
import { DataPointProvider } from './contexts/DataPointContext';
import { MapModeProvider, useMapMode, MAP_MODES } from './contexts/MapModeContext';
import logo from './logo.png';
import './App.css';
import './components/FilterCategories.css';

const App = () => {
  return (
    <GraphProvider>
      <SelectionProvider>
        <SearchProvider>
          <CogcOverlayProvider>
            <DataPointProvider>
              <MapModeProvider>
                 <AppContent />
              </MapModeProvider>
            </DataPointProvider>
          </CogcOverlayProvider>
        </SearchProvider>
      </SelectionProvider>
    </GraphProvider>
  );
};

const AppContent = () => {
  const { activeMode, toggleMode } = useMapMode();

  return (
    <div className="App">
      <header className="App-header">
        <div className="header-left">
          <img src={logo} alt="Logo" className="App-logo" />
          <h1>Taiyi's Prosperous Universe Map</h1>
        </div>
        
        <div className="header-center">
            {activeMode === MAP_MODES.STANDARD ? <StandardControls /> : <GatewayControls />}
        </div>

        <div className="header-right">
          <div className="global-tools">
             <button 
                className={`toggle-token mode-switch-btn ${activeMode === MAP_MODES.GATEWAY ? 'active' : ''}`}
                onClick={toggleMode}
                title="Toggle Gateway Planning Mode"
             >
                {activeMode === MAP_MODES.STANDARD ? 'Gateway Planner' : 'Exit Planner'}
             </button>
             
             <div className="tool-separator"></div>

             <InfoTooltip />
             <div className="mini-stack">
                <div className="pathfinding-toggle-container">
                    <PathfindingToggle />
                </div>
                <div className="pathfinding-toggle-container">
                    <MeteorDensityToggle />
                </div>
             </div>
          </div>
        </div>
      </header>
      
      <div className="main-content">
        <UniverseMap />
        <Sidebar />
      </div>
    </div>
  );
};

export default App;

--- FILE: src/App.test.js ---

import { render, screen } from '@testing-library/react';
import App from './App';

test('renders learn react link', () => {
  render(<App />);
  const linkElement = screen.getByText(/learn react/i);
  expect(linkElement).toBeInTheDocument();
});


--- FILE: src/index.css ---

body {
  margin: 0;
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen',
    'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue',
    sans-serif;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

code {
  font-family: source-code-pro, Menlo, Monaco, Consolas, 'Courier New',
    monospace;
}


--- FILE: src/index.js ---

import React from 'react';
import ReactDOM from 'react-dom/client';
import './index.css';
import App from './App';
import reportWebVitals from './reportWebVitals';

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);

// If you want to start measuring performance in your app, pass a function
// to log results (for example: reportWebVitals(console.log))
// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals
reportWebVitals();


--- FILE: src/reportWebVitals.js ---

const reportWebVitals = onPerfEntry => {
  if (onPerfEntry && onPerfEntry instanceof Function) {
    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {
      getCLS(onPerfEntry);
      getFID(onPerfEntry);
      getFCP(onPerfEntry);
      getLCP(onPerfEntry);
      getTTFB(onPerfEntry);
    });
  }
};

export default reportWebVitals;


--- FILE: src/setupTests.js ---

// jest-dom adds custom jest matchers for asserting on DOM nodes.
// allows you to do things like:
// expect(element).toHaveTextContent(/react/i)
// learn more: https://github.com/testing-library/jest-dom
import '@testing-library/jest-dom';


--- FILE: src/contexts/CogcOverlayContext.js ---

import React, { createContext, useState, useContext } from 'react';

const CogcOverlayContext = createContext();

export const CogcOverlayProvider = ({ children }) => {
  const [overlayProgram, setOverlayProgram] = useState(null);

  return (
    <CogcOverlayContext.Provider value={{ overlayProgram, setOverlayProgram }}>
      {children}
    </CogcOverlayContext.Provider>
  );
};

export const useCogcOverlay = () => useContext(CogcOverlayContext);

--- FILE: src/contexts/DataPointContext.js ---

import React, { createContext, useState, useContext, useCallback, useMemo, useEffect } from 'react';

// Create the context
export const DataPointContext = createContext();

export const DataPointProvider = ({ children }) => {
  // State for system meteorite density data
  const [meteorDensityData, setMeteorDensityData] = useState({});
  const [luminosityData, setLuminosityData] = useState({});
  const [systemNames, setSystemNames] = useState({});
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState(null);

  // Visibility toggle for the overlay
  const [isOverlayVisible, setIsOverlayVisible] = useState(false);

  // Scale setting (absolute vs relative)
  const [useRelativeScale, setUseRelativeScale] = useState(false);

  // Fetch system stars data
  // In src/contexts/DataPointContext.js

  // Fetch system stars data
  useEffect(() => {
    const fetchOverlayData = async () => {
      try {
        setIsLoading(true);
        const [staticResponse, freshResponse] = await Promise.all([
          fetch('systemstars.json'),         // The old, enriched file with Luminosity/Density
          fetch('prun_universe_data.json') // The file that will be updated weekly with fresh names
        ]);

        if (!staticResponse.ok || !freshResponse.ok) {
          throw new Error('Failed to fetch all necessary system data');
        }

        const staticData = await staticResponse.json();
        const freshData = await freshResponse.json();

        const freshSystemNamesMap = new Map(
            freshData.map(system => [system.SystemId, system.Name])
        );

        const densityMap = {};
        const luminosityMap = {};
        const finalSystemNameMap = {};

        staticData.forEach(system => {
          densityMap[system.SystemId] = system.MeteoroidDensity;
          luminosityMap[system.SystemId] = system.Luminosity;
          
          const freshName = freshSystemNamesMap.get(system.SystemId);
          
          finalSystemNameMap[system.SystemId] = freshName || system.Name;
        });

        setMeteorDensityData(densityMap);
        setLuminosityData(luminosityMap);
        setSystemNames(finalSystemNameMap);
        setError(null);

      } catch (err) {
        console.error('Error fetching and combining overlay data:', err);
        setError(err.message);
      } finally {
        setIsLoading(false);
      }
    };

    fetchOverlayData();
  }, []);

  // Get meteorite density for a specific system
  const getSystemMeteorDensity = useCallback((systemId) => {
    return meteorDensityData[systemId] || 0;
  }, [meteorDensityData]);

  const getSystemLuminosity = useCallback((systemId) => {
    return luminosityData[systemId] || 0;
  }, [luminosityData]);

  // Toggle overlay visibility
  const toggleOverlayVisibility = useCallback(() => {
    setIsOverlayVisible(prev => !prev);
  }, []);

  // Toggle scale type
  const toggleScaleType = useCallback(() => {
    setUseRelativeScale(prev => !prev);
  }, []);

  // Get maximum density and luminosity value for relative scaling
  const maxValues = useMemo(() => ({
    density: Math.max(0, ...Object.values(meteorDensityData)),
    luminosity: Math.max(0, ...Object.values(luminosityData))
  }), [meteorDensityData, luminosityData]);

  // Calculate normalized density based on scale type
  const getNormalizedValue = useCallback((value, type) => {
    if (!useRelativeScale) return value;
    const maxValue = maxValues[type];
    return maxValue === 0 ? 0 : value / maxValue;
  }, [useRelativeScale, maxValues]);

  const contextValue = {
    meteorDensityData,
    luminosityData,
    systemNames,
    isOverlayVisible,
    useRelativeScale,
    isLoading,
    error,
    getSystemMeteorDensity,
    getSystemLuminosity,
    toggleOverlayVisibility,
    toggleScaleType,
    getNormalizedValue,
    maxValues
  };

  return (
<DataPointContext.Provider value={contextValue}>
{children}
</DataPointContext.Provider>
);
};

// Custom hook for using the data point context
export const useDataPoints = () => {
const context = useContext(DataPointContext);
if (!context) {
throw new Error('useDataPoints must be used within a DataPointProvider');
}
return context;
};

--- FILE: src/contexts/GraphContext.js ---

import React, { createContext, useState, useEffect, useCallback } from 'react';
import { findShortestPath as findShortestPathUtil, highlightPath} from '../utils/graphUtils';

export const GraphContext = createContext();

export const GraphProvider = ({ children }) => {
  const [graph, setGraph] = useState({ nodes: {}, edges: [] });
  const [materials, setMaterials] = useState({});
  const [selectedSystems, setSelectedSystems] = useState([]);
  const [planetData, setPlanetData] = useState({});
  const [universeData, setUniverseData] = useState({});
  const [populationData, setPopulationData] = useState({});

  useEffect(() => {
    console.log('Fetching graph data');
    fetch('graph_data.json')
      .then(response => response.json())
      .then(data => {
        setGraph(data);
      })
      .catch(error => {
        console.error('Error fetching graph data:', error);
      });

    fetch('material_data.json')
      .then(response => response.json())
      .then(data => {
        setMaterials(data);
      })
      .catch(error => {
        console.error('Error fetching material data:', error);
      });

    fetch('prun_universe_data.json')
      .then(response => response.json())
      .then(data => {
        // Group planets by SystemId
        const groupedUniverseData = data.reduce((acc, system) => {
          if (!acc[system.SystemId]) {
            acc[system.SystemId] = [];
          }
          acc[system.SystemId].push(system);
          return acc;
        }, {});
        setUniverseData(groupedUniverseData);
      })
      .catch(error => {
        console.error('Error fetching universe data:', error);
      });

    // Fetch planet data
    fetch('planet_data.json')
      .then(response => response.json())
      .then(data => {
        // Group planets by SystemId
        const groupedPlanetData = data.reduce((acc, planet) => {
          if (!acc[planet.SystemId]) {
            acc[planet.SystemId] = [];
          }
          acc[planet.SystemId].push(planet);
          return acc;
        }, {});
        setPlanetData(groupedPlanetData);
      })
      .catch(error => {
        console.error('Error fetching planet data:', error);
      });

    // Fetch Population Data
    fetch('population_data.json')
      .then(response => response.json())
      .then(data => {
        setPopulationData(data);
      })
      .catch(error => {
        console.warn('Population data not loaded or file missing', error);
      });

  }, []);

  const findShortestPath = useCallback((system1, system2) => {
    findShortestPathUtil(graph, system1, system2, highlightPath);
  }, [graph]);


  return (
    <GraphContext.Provider
      value={{
        graph,
        setGraph,
        materials,
        setMaterials,
        selectedSystems,
        setSelectedSystems,
        findShortestPath,
        planetData,
        universeData,
        populationData
      }}
    >
      {children}
    </GraphContext.Provider>
  );
};

--- FILE: src/contexts/MapModeContext.js ---

import React, { createContext, useState, useContext, useCallback } from 'react';

export const MAP_MODES = {
  STANDARD: 'STANDARD',
  GATEWAY: 'GATEWAY'
};

export const GATEWAY_STRATEGIES = {
  SINGLE: 'SINGLE',
  DUAL: 'DUAL'
};

const MapModeContext = createContext();

export const MapModeProvider = ({ children }) => {
  const [activeMode, setActiveMode] = useState(MAP_MODES.STANDARD);
  
  // Gateway specific state
  const [gatewayData, setGatewayData] = useState({
    originA: null,
    originB: null,
    strategy: GATEWAY_STRATEGIES.SINGLE,
    plannedGateways: [] // Array of { id, source, target, distance }
  });

  const toggleMode = useCallback(() => {
    setActiveMode(prev => prev === MAP_MODES.STANDARD ? MAP_MODES.GATEWAY : MAP_MODES.STANDARD);
  }, []);

  const setGatewayStrategy = useCallback((strategy) => {
    setGatewayData(prev => ({ ...prev, strategy }));
  }, []);

  const addPlannedGateway = useCallback((gateway) => {
    setGatewayData(prev => ({
      ...prev,
      plannedGateways: [...prev.plannedGateways, gateway]
    }));
  }, []);

  const removePlannedGateway = useCallback((gatewayId) => {
    setGatewayData(prev => ({
      ...prev,
      plannedGateways: prev.plannedGateways.filter(g => g.id !== gatewayId)
    }));
  }, []);

  const clearGatewaySelections = useCallback(() => {
    setGatewayData(prev => ({
      ...prev,
      originA: null,
      originB: null
    }));
  }, []);

  return (
    <MapModeContext.Provider value={{
      activeMode,
      toggleMode,
      gatewayData,
      setGatewayData,
      setGatewayStrategy,
      addPlannedGateway,
      removePlannedGateway,
      clearGatewaySelections
    }}>
      {children}
    </MapModeContext.Provider>
  );
};

export const useMapMode = () => useContext(MapModeContext);

--- FILE: src/contexts/SearchContext.js ---

import React, { createContext, useState, useCallback, useContext } from 'react';
import { GraphContext } from './GraphContext';
import { highlightSearchResults, clearHighlights } from '../utils/searchUtils';


export const SearchContext = createContext();

const sanitizeInput = (input) => {
  // Remove any HTML tags
  let sanitized = input.replace(/<[^>]*>/g, '');
  // Remove special characters except spaces, hyphens, and parentheses
  sanitized = sanitized.replace(/[^a-zA-Z0-9\s\-()]/g, '');
  // Trim whitespace from the beginning and end
  sanitized = sanitized.trim();
  // Limit the length of the input
  const maxLength = 500;
  sanitized = sanitized.slice(0, maxLength);

  return sanitized;
};

// Helper function to split camelCase into separate words.
const splitCamelCase = (str) => {
  return str.replace(/([a-z])([A-Z])/g, '$1 $2').toLowerCase();
};

export const SearchProvider = ({ children }) => {
  const [searchResults, setSearchResults] = useState([]);
  const { universeData, planetData, materials } = useContext(GraphContext);
  const [searchMaterial, setSearchMaterial] = useState([]);
  const [searchMaterialConcentrationLiquid, setSearchMaterialConcentrationLiquid] = useState([]);
  const [searchMaterialConcentrationGaseous, setSearchMaterialConcentrationGaseous] = useState([]);
  const [searchMaterialConcentrationMineral, setSearchMaterialConcentrationMineral] = useState([]);
  const [filters, setFilters] = useState({
    planetType: ['Rocky', 'Gaseous'],
    gravity: ['Low', 'High'],
    temperature: ['Low', 'High'],
    pressure: ['Low', 'High'],
    cogcProgram: []
  });
  const [systemSearchTerm, setSystemSearchTerm] = useState('');
  const [materialSearchTerm, setMaterialSearchTerm] = useState('');
  const [resourceThreshold, setResourceThreshold] = useState(0);
  const [isRelativeThreshold, setIsRelativeThreshold] = useState(false);
  const [resourceTypeFilter, setResourceTypeFilter] = useState('ALL');
  const [companySearchTerm, setCompanySearchTerm] = useState('');
  const [isCompanySearch, setIsCompanySearch] = useState(false);


  const handleSystemSearch = useCallback((searchTerm) => {
    const sanitizedSearchTerm = sanitizeInput(searchTerm);
    const results = [];
    const terms = sanitizedSearchTerm.split(/\s+/)
        .filter(term => term.length >= 2); // Only keep terms with 1 or more characters

    terms.forEach(term => {
      const lowerTerm = term.toLowerCase();

      // Search in systems
      Object.entries(universeData).forEach(([systemId, systemArray]) => {
      let system = systemArray[0]
        if (system.Name.toLowerCase().includes(term.toLowerCase()) ||
            system.NaturalId.toLowerCase().includes(term.toLowerCase())) {
          results.push({ type: 'system', id: systemId });
        }
      });

      // Search in planets
      Object.entries(planetData).forEach(([systemId, planets]) => {
        planets.forEach(planet => {
          if (planet.PlanetName.toLowerCase().includes(lowerTerm) ||
              planet.PlanetNaturalId.toLowerCase().includes(lowerTerm)) {
            results.push({ type: 'planet', id: planet.PlanetNaturalId, systemId: systemId });
          }
        });
      });
    });

    console.log('Results', results);
    setSearchResults(results);
    highlightSearchResults(results);
    return results;
  }, [universeData, planetData]);


  const handleMaterialSearch = useCallback((searchTerm) => {
    const sanitizedSearchTerm = sanitizeInput(searchTerm);
    const terms = sanitizedSearchTerm.split(/\s+/)
        .filter(term => term.length >= 1); // Only keep terms with 1 or more characters

    let results = [];
    let matchingMaterialIds = [];

    if (terms.length === 0) {
      // Populate results with all planets if no search terms
      Object.entries(planetData).forEach(([systemId, planets]) => {
        planets.forEach(planet => {
          results.push({
            type: 'planet',
            planetId: planet.PlanetNaturalId,
            systemId: systemId
          });
        });
      });
    } else {
      // Find materials matching the search terms
      const matchingMaterials = terms.map(term => {
        const lowerTerm = term.toLowerCase();
        const regex = new RegExp(`\\b${lowerTerm}\\b`, 'i');
        return materials.filter(material =>
          (regex.test(splitCamelCase(material.Name)) || regex.test(material.Ticker.toLowerCase())) &&
          ['ores', 'gases', 'liquids', 'minerals'].includes(material.CategoryName)
        );
      });

      matchingMaterialIds = matchingMaterials.flat().map(material => material.MaterialId);

      // Find planets that have all specified materials
      Object.entries(planetData).forEach(([systemId, planets]) => {
        planets.forEach(planet => {
          const hasAllMaterials = matchingMaterials.every(materialList =>
            materialList.some(material =>
              planet.Resources.some(resource => resource.MaterialId === material.MaterialId)
            )
          );

          if (hasAllMaterials) {
            const planetResources = matchingMaterials.flatMap(materialList =>
              materialList.filter(material =>
                planet.Resources.some(resource => resource.MaterialId === material.MaterialId)
              )
            );

            planetResources.forEach(material => {
              const resource = planet.Resources.find(r => r.MaterialId === material.MaterialId);
              results.push({
                type: 'material',
                id: material.MaterialId,
                name: material.Name,
                ticker: material.Ticker,
                planetId: planet.PlanetNaturalId,
                systemId: systemId,
                factor: resource.Factor,
                resourceType: resource.ResourceType
              });
            });
          }
        });
      });
    }

    const filteredResults = results.filter(result => {
      const planet = planetData[result.systemId].find(p => p.PlanetNaturalId === result.planetId);

      if (!planet) {
        console.warn(`Planet not found for result:`, result);
        return false;
      }

      if (result.type === 'material') {
        // Apply resource type filter
        if (resourceTypeFilter !== 'ALL' && result.resourceType !== resourceTypeFilter) {
          return false;
        }

        // Apply factor check
        let factorCheck;
        if (isRelativeThreshold) {
          let maxFactor;
          if (resourceTypeFilter === 'ALL') {
            // Use global maximum when 'ALL' is selected
            maxFactor = Math.max(...results
              .filter(r => r.type === 'material')
              .map(r => r.factor));
          } else {
            // Use type-specific maximum when a specific type is selected
            maxFactor = Math.max(...results
              .filter(r => r.type === 'material' && r.resourceType === resourceTypeFilter)
              .map(r => r.factor));
          }
          const relativeFactor = result.factor / maxFactor;
          factorCheck = relativeFactor >= resourceThreshold;
        } else {
          factorCheck = result.factor >= resourceThreshold;
        }

        if (!factorCheck) {
          return false;
        }
      }

      const planetTypeCondition =
        (filters.planetType.includes('Rocky') && planet.Surface) ||
        (filters.planetType.includes('Gaseous') && !planet.Surface);

      const planetFertility =
       (filters.planetType.includes('Fertile') && planet.Fertility > -1) ||
       (!filters.planetType.includes('Fertile'));

      const gravityCondition =
        (filters.gravity.includes('Low') && (planet.Gravity < 0.25)) ||
        (filters.gravity.includes('High') && (planet.Gravity >= 2.5)) ||
        ((0.25 <= planet.Gravity) && (planet.Gravity <= 2.5));

      const temperatureCondition =
        (filters.temperature.includes('Low') && (planet.Temperature < -25.0)) ||
        (filters.temperature.includes('High') && (planet.Temperature >= 75.0)) ||
        ((-25.0 <= planet.Temperature) && (planet.Temperature <= 75.0));

      const pressureCondition =
        (filters.pressure.includes('Low') && (planet.Pressure < 0.25)) ||
        (filters.pressure.includes('High') && (planet.Pressure >= 2.0)) ||
        ((0.25 <= planet.Pressure) && (planet.Pressure <= 2.0));

      const cogcCondition = filters.cogcProgram.length === 0 ||
        (planet.HasChamberOfCommerce && (
          filters.cogcProgram.includes('ALL') ||
          filters.cogcProgram.some(selectedProgram => {
            const programs = planet.COGCPrograms || [];
            const sortedPrograms = programs.sort((a, b) => b.StartEpochMs - a.StartEpochMs);
            const currentProgram = sortedPrograms[1] || sortedPrograms[0] || null;
            if (selectedProgram === null) {
              return !currentProgram || currentProgram.ProgramType === null;
            }

            return currentProgram && currentProgram.ProgramType === selectedProgram;
          })
        ));

      return planetTypeCondition && planetFertility && gravityCondition && temperatureCondition &&
             pressureCondition && cogcCondition;
    });

    // Remove duplicates
    const uniqueResults = Array.from(new Set(filteredResults.map(JSON.stringify))).map(JSON.parse);
    // Obtain the highest concentration
    const highestFactorLiquid = uniqueResults
      .filter(result => result.resourceType === 'LIQUID')
      .reduce((max, item) => item.factor > max ? item.factor : max, -Infinity);
    setSearchMaterialConcentrationLiquid(highestFactorLiquid)
    const highestFactorGaseous = uniqueResults
      .filter(result => result.resourceType === 'GASEOUS')
      .reduce((max, item) => item.factor > max ? item.factor : max, -Infinity);
    setSearchMaterialConcentrationGaseous(highestFactorGaseous)
    const highestFactorMineral = uniqueResults
      .filter(result => result.resourceType === 'MINERAL')
      .reduce((max, item) => item.factor > max ? item.factor : max, -Infinity);
    setSearchMaterialConcentrationMineral(highestFactorMineral)

    console.log('Results', uniqueResults);
    setSearchResults(uniqueResults);
    highlightSearchResults(uniqueResults, highestFactorLiquid, highestFactorGaseous, highestFactorMineral);
    setSearchMaterial(matchingMaterialIds);
    return uniqueResults;
  }, [planetData, materials, filters, resourceThreshold, isRelativeThreshold, resourceTypeFilter]);

  const handleCompanySearch = useCallback(async (companyCode) => {
    const sanitizedCompanyCode = sanitizeInput(companyCode);
    try {
      const response = await fetch(`https://rest.fnar.net/company/code/${sanitizedCompanyCode}`);
      const data = await response.json();

      if (data && data.Planets) {
        const results = data.Planets.map(planet => ({
          type: 'company_base',
          planetId: planet.PlanetId,
          planetNaturalId: planet.PlanetNaturalId,
          planetName: planet.PlanetName,
          systemId: Object.keys(planetData).find(systemId =>
          planetData[systemId].some(p => p.PlanetNaturalId === planet.PlanetNaturalId)
          )
        }));

        setSearchResults(results);
        highlightSearchResults(results);
        return results;
      } else {
        return [];
      }
    } catch (error) {
      console.error('Error fetching company data:', error);
      return [];
    }
  }, [planetData]);


  const clearSearch = useCallback(() => {
    setSearchResults([]);
    setSystemSearchTerm('');
    setMaterialSearchTerm('');
    setCompanySearchTerm('');
    setSearchMaterial([]);
    setSearchMaterialConcentrationLiquid([]);
    setSearchMaterialConcentrationGaseous([]);
    setSearchMaterialConcentrationMineral([]);
    clearHighlights();
  }, []);

  const updateFilters = useCallback((newFilters) => {
    setFilters(newFilters);
  }, []);

  const updateSystemSearchTerm = useCallback((term) => {
    setSystemSearchTerm(term);
  }, []);

  const updateMaterialSearchTerm = useCallback((term) => {
    setMaterialSearchTerm(term);
  }, []);

  const updateCompanySearchTerm = useCallback((term) => {
    setCompanySearchTerm(term);
  }, []);

  const toggleCompanySearch = useCallback(() => {
    setIsCompanySearch(prev => !prev);
    clearSearch();
  }, [clearSearch]);


  return (
    <SearchContext.Provider
      value={{
        searchResults,
        searchMaterial,
        searchMaterialConcentrationLiquid,
        searchMaterialConcentrationMineral,
        searchMaterialConcentrationGaseous,
        handleSystemSearch,
        handleMaterialSearch,
        handleCompanySearch,
        clearSearch,
        filters,
        updateFilters,
        systemSearchTerm,
        materialSearchTerm,
        companySearchTerm,
        updateSystemSearchTerm,
        updateMaterialSearchTerm,
        updateCompanySearchTerm,
        resourceThreshold,
        setResourceThreshold,
        isRelativeThreshold,
        setIsRelativeThreshold,
        resourceTypeFilter,
        setResourceTypeFilter,
        isCompanySearch,
        toggleCompanySearch,
      }}
    >
      {children}
    </SearchContext.Provider>
  );
};

--- FILE: src/contexts/SelectionContext.js ---

import React, { createContext, useState, useCallback, useContext } from 'react';
import { highlightSelectedSystem as highlightSelectedSystemUtil } from '../utils/graphUtils';
import { GraphContext } from '../contexts/GraphContext';

export const SelectionContext = createContext();

export const SelectionProvider = ({ children }) => {
  const [isPathfindingEnabled, setIsPathfindingEnabled] = useState(false);
  const [selectedSystem, setSelectedSystem] = useState(null);
  const [pathfindingSelection, setPathfindingSelection] = useState([]);

  const { findShortestPath } = useContext(GraphContext);

  const togglePathfinding = useCallback(() => {
  setIsPathfindingEnabled(prev => {
    if (prev) {
      // If turning off pathfinding, reset the graph state
      highlightSelectedSystemUtil(null, null, [], prev);
    }
    return !prev;
  });
  setPathfindingSelection([]); // Reset selection when toggling
}, []);

const highlightSelectedSystem = useCallback((nextSelectedSystem) => {
  if (isPathfindingEnabled) {
    setPathfindingSelection(prev => {
      let newSelection;
      if (prev.length === 2) {
        // Reset selection if it already has two entries
        newSelection = [nextSelectedSystem];
      } else {
        // Add new selection, keeping at most 2 entries
        newSelection = [...prev, nextSelectedSystem].slice(-2);
      }

      // Always update selectedSystem
      setSelectedSystem(prevSelectedSystem => {
        if (newSelection.length === 1) {
          highlightSelectedSystemUtil(prevSelectedSystem, nextSelectedSystem, newSelection, isPathfindingEnabled);
        }
        return nextSelectedSystem;
      });
      // If we now have 2 systems selected, find the shortest path
        if (newSelection.length === 2) {
          findShortestPath(newSelection[0], newSelection[1]);
        }
      return newSelection;
    });
  } else {
    // Behavior when pathfinding is disabled
    setSelectedSystem(prevSelectedSystem => {
      highlightSelectedSystemUtil(prevSelectedSystem, nextSelectedSystem, [], isPathfindingEnabled);
      return nextSelectedSystem;
    });
  }
}, [isPathfindingEnabled, findShortestPath]);








  return (
    <SelectionContext.Provider
      value={{
        isPathfindingEnabled,
        togglePathfinding,
        selectedSystem,
        pathfindingSelection,
        highlightSelectedSystem
      }}
    >
      {children}
    </SelectionContext.Provider>
  );
};

--- FILE: src/utils/dataPointUtils.js ---

import * as d3 from 'd3';

// Calculate bar dimensions based on node size and zoom level
export const calculateBarDimensions = (nodeWidth, nodeHeight, zoomLevel) => {
  const barWidth = Math.max(2, nodeWidth * 0.15 / zoomLevel); // 15% of node width
  const barHeight = nodeHeight / zoomLevel;
  const xOffset = nodeWidth + (barWidth / 2); // Position right of node
  const yOffset = 0; // Align with top of node

  return {
    barWidth,
    barHeight,
    xOffset,
    yOffset
  };
};

// Calculate color based on density value
export const getDensityColor = (density, maxDensity) => {
  // Color scale from yellow (low) to red (high)
  const colorScale = d3.scaleLinear()
    .domain([0, maxDensity])
    .range(['#FFD700', '#FF4500']); // Gold to Red-Orange

  return colorScale(density);
};

// Calculate bar height based on density value
export const calculateBarHeight = (density, maxDensity, maxHeight) => {
  if (maxDensity === 0) return 0;

  const scale = d3.scaleLinear()
    .domain([0, maxDensity])
    .range([0, maxHeight]);

  return scale(density);
};

// Format density value for display
export const formatDensityValue = (density) => {
  return density.toFixed(2);
};

// Calculate tooltip position
export const calculateTooltipPosition = (event, nodeWidth, nodeHeight) => {
  const { pageX, pageY } = event;
  const tooltipOffset = 10; // Offset from cursor

  return {
    x: pageX + tooltipOffset,
    y: pageY - tooltipOffset
  };
};

// Helper function to determine if a point is near a bar
export const isPointNearBar = (point, barPosition, barDimensions) => {
  const { x, y } = point;
  const { x: barX, y: barY } = barPosition;
  const { barWidth, barHeight } = barDimensions;

  return (
  x >= barX &&
  x <= barX + barWidth &&
  y >= barY &&
  y <= barY + barHeight
  );
};

--- FILE: src/utils/graphUtils.js ---

import * as d3 from 'd3';
import { find_path } from 'dijkstrajs';
import { colors } from '../config/config';

export const findShortestPath = (graph, system1, system2, highlightPath) => {
  if (system1 === 'rect1' || system2 === 'rect1') {
    console.error('Invalid system selection for pathfinding:', system1, system2);
    return;
  }

  const graphNodes = {};
  graph.edges.forEach(edge => {
    if (!graphNodes[edge.start]) graphNodes[edge.start] = {};
    if (!graphNodes[edge.end]) graphNodes[edge.end] = {};
    graphNodes[edge.start][edge.end] = edge.distance;
    graphNodes[edge.end][edge.start] = edge.distance;
  });

  try {
    const path = find_path(graphNodes, system1, system2);
    console.log('Found Path:', path)
    highlightPath(path, system2);
  } catch (error) {
    console.error('Error finding path:', error);
  }
};

// Function to reset all nodes and paths
export const resetGraphState = (nextSelectedSystem) => {
  const svg = d3.select('#map-container svg');
  // Reset all system nodes color and stroke except the background rect and current selection
  svg.selectAll('rect').each(function() {
    const node = d3.select(this);
    const systemId = node.attr('id');
    if (systemId !== 'rect1'
      && systemId !== nextSelectedSystem
      && !node.classed('search-highlight')
      && !node.classed('cogc-overlay-rect')
      && !node.classed('data-overlay')
      ) {
      node
        .attr('fill', colors.resetSystemFill)
        .attr('fill-opacity', colors.resetSystemFillOpacity)
        .attr('stroke', colors.resetSystemStroke)
        .attr('stroke-width', colors.resetSystemStrokeWidth);
    }
  });

  // Reset all paths color and stroke
  svg.selectAll('path').each(function() {
    d3.select(this)
      .attr('stroke', colors.resetPathStroke)
      .attr('stroke-width', colors.resetPathStrokeWidth);
  });
};

// Function to highlight the path
export const highlightPath = (path, systemSelected) => {
  // Reset all system nodes color and stroke except the background rect
  resetGraphState(systemSelected)

  // Highlight systems in the path
  path.forEach(system => {
  const systemNode = d3.select(`#${CSS.escape(system)}`);
    if (!systemNode.classed('search-highlight')) {
      systemNode
        .attr('fill', colors.systemFill)
        .attr('stroke', colors.systemStroke);
    }
  });

  // Highlight paths in the path
  for (let i = 0; i < path.length - 1; i++) {
    const start = path[i];
    const end = path[i + 1];

    d3.selectAll(`path[id*="${start}"][id*="${end}"], path[id*="${end}"][id*="${start}"]`)
      .attr('stroke', colors.pathStroke)
      .attr('stroke-width', colors.pathStrokeWidth);
  }

  // Ensure the start and end systems of the path are highlighted
  if (path.length >= 2) {
    const startSystem = path[0];
    const endSystem = path[path.length - 1];
    highlightSelectedSystem(null, startSystem, [startSystem, endSystem]);
    highlightSelectedSystem(null, endSystem, [startSystem, endSystem]);
  }
};

export const highlightSelectedSystem = (prevSelectedSystem, nextSelectedSystem, pathfindingSelection, isPathfindingEnabled) => {

  // Check if pathfindingSelection is empty, if so reset all nodes
  if (pathfindingSelection.length < 2 && isPathfindingEnabled) {
    resetGraphState(nextSelectedSystem);
  }

  // Reset previous system if it's not part of pathfinding selection
  if (prevSelectedSystem && !pathfindingSelection.includes(prevSelectedSystem)) {
    const prevSystemNode = d3.select(`#${CSS.escape(prevSelectedSystem)}`);
    if (!prevSystemNode.empty() && !prevSystemNode.classed('search-highlight')) {
      prevSystemNode
        .attr('fill', colors.resetSystemFill)
        .attr('fill-opacity', colors.resetSystemFillOpacity)
        .attr('stroke', colors.resetSystemStroke)
        .attr('stroke-width', colors.resetSystemStrokeWidth);
    }
  }

  // Highlight new system
  if (nextSelectedSystem) {
    const nextSystemNode = d3.select(`#${CSS.escape(nextSelectedSystem)}`);
    if (!nextSystemNode.empty() && !nextSystemNode.classed('search-highlight')) {
      nextSystemNode
        .attr('fill', colors.systemFill)
        .attr('stroke', colors.systemStroke)
        .attr('stroke-width', colors.systemStrokeWidth);
    }
  }
};


--- FILE: src/utils/searchUtils.js ---

import * as d3 from 'd3';
import { resetGraphState } from '../utils/graphUtils';
import { colors } from '../config/config';

export const clearHighlights = () => {
  d3.selectAll('.search-highlight')
    .classed('search-highlight', false)
    .attr('fill', colors.resetSystemFill)
    .attr('stroke', colors.resetSystemStroke)
    .attr('stroke-width', colors.resetSystemStrokeWidth);

  resetGraphState();
};

export const highlightSearchResults = (searchResults, highestFactorLiquid, highestFactorGaseous, highestFactorMineral) => {
  console.log(highestFactorLiquid, highestFactorGaseous, highestFactorMineral)
  // Define color scales
  const colorScaleLiquid = d3.scaleLinear()
    .domain([0, highestFactorLiquid])
    .range([colors.searchSystemFillLowLiquid, colors.searchSystemFillLiquid]);
  const colorScaleGaseous = d3.scaleLinear()
    .domain([0, highestFactorGaseous])
    .range([colors.searchSystemFillLowGaseous, colors.searchSystemFillGaseous]);
  const colorScaleMineral = d3.scaleLinear()
    .domain([0, highestFactorMineral])
    .range([colors.searchSystemFillLowMineral, colors.searchSystemFillMineral]);

  if (searchResults.length > 0) {
    // Reset all systems to default state
    clearHighlights();

    // Track the best resource for each system
    const systemBestResource = {};

    // First pass: determine the best resource to highlight for each system
    searchResults.forEach(result => {
      if (result.type === 'material') {
        const systemId = result.systemId;
        if (!systemBestResource[systemId]) {
          systemBestResource[systemId] = result;
        } else {
          const current = systemBestResource[systemId];
          // Simply keep the resource with the highest concentration
          if (result.factor > current.factor) {
            systemBestResource[systemId] = result;
          }
        }
      } else if (result.type === 'company_base') {
        const systemId = result.systemId;
        if (!systemBestResource[systemId]) {
          systemBestResource[systemId] = result;
        }
      }
    });

    // Second pass: highlight systems based on the best resource
    searchResults.forEach(result => {
      let highlightSystemNode = {};
      let fillColor = colors.searchSystemFill;
      let systemId;

      if (result.type === 'system') {
        systemId = result.id;
        highlightSystemNode = d3.select(`#${CSS.escape(systemId)}`);
      } else if (result.type === 'planet') {
        systemId = result.systemId;
        highlightSystemNode = d3.select(`#${CSS.escape(systemId)}`);
      } else if (result.type === 'material') {
        systemId = result.systemId;
        const bestForSystem = systemBestResource[systemId];

        if (result === bestForSystem) {
          if (result.resourceType === 'LIQUID') {
            fillColor = colorScaleLiquid(result.factor);
          } else if (result.resourceType === 'GASEOUS') {
            fillColor = colorScaleGaseous(result.factor);
          } else {
            fillColor = colorScaleMineral(result.factor);
          }
          highlightSystemNode = d3.select(`#${CSS.escape(systemId)}`);
        } else {
          // Skip this result as it's not the best for the system
          return;
        }
      } else if (result.type === 'company_base') {
        systemId = result.systemId;
        highlightSystemNode = d3.select(`#${CSS.escape(systemId)}`);
      }

      if (!highlightSystemNode.empty()) {
        highlightSystemNode
          .attr('fill', fillColor)
          .attr('stroke', colors.searchSystemStroke)
          .attr('stroke-width', colors.searchSystemStrokeWidth)
          .attr('fill-opacity', 1.0)
          .classed('search-highlight', true);
      }
    });
  }
};

--- FILE: src/utils/svgUtils.js ---

import * as d3 from 'd3';
import React from 'react';
import ReactDOMServer from 'react-dom/server';
import { BadgeCent, Anchor, Truck, BookOpen, Globe } from 'lucide-react';
import { colors } from '../config/config';

let universeData = null;
let planetData = null;
let universeMaxConcentrations = null;

// Function to fetch and process the universe and planet data
const fetchData = async () => {
  try {
    const [universeResponse, planetResponse] = await Promise.all([
      fetch('prun_universe_data.json'),
      fetch('planet_data.json')
    ]);
    const universeJson = await universeResponse.json();
    const planetJson = await planetResponse.json();

    universeData = Object.fromEntries(universeJson.map(system => [system.SystemId, system]));

    // Group planets by SystemId
    planetData = planetJson.reduce((acc, planet) => {
      if (!acc[planet.SystemId]) {
        acc[planet.SystemId] = [];
      }
      acc[planet.SystemId].push(planet);
      return acc;
    }, {});

    universeMaxConcentrations = calculateMaxConcentrations(Object.values(planetData).flat());

    console.log('Universe and planet data loaded');
  } catch (error) {
    console.error('Error loading data:', error);
  }
};

// Call this function when the application initializes
fetchData();

const calculateMaxConcentrations = (planets) => {
  const maxConc = {};

  planets.forEach(planet => {
    planet.Resources.forEach(resource => {
      const key = `${resource.MaterialId}-${resource.ResourceType}`;
      if (!maxConc[key] || resource.Factor > maxConc[key]) {
        maxConc[key] = resource.Factor;
      }
    });
  });

  return maxConc;
};

// Function to create facility indicator
const createFacilityIndicator = (hasFeature, IconComponent) => {
  const color = hasFeature ? '#f7a600' : '#3d3846';
  const iconElement = React.createElement(IconComponent, {
    size: 18,
    color: color,
    strokeWidth: 1.5,
    style: { marginRight: '2px' }
  });

  return ReactDOMServer.renderToString(iconElement);
};

const determinePlanetTier = (buildRequirements = []) => {
  // Distinct tickers; unknowns ignored
  const PENALTY = {
    SEA: 0,
    MCG: 0,
    BL:  1,
    INS: 1,
    HSE: 1,
    AEF: 1,
    MGC: 2,
    TSH: 2,
  };

  // De-duplicate tickers found in requirements
  const tickers = Array.from(new Set(
    (buildRequirements || [])
      .map(r => (r?.MaterialTicker || r?.Material || '').toUpperCase())
      .filter(Boolean)
  ));

  const totalPenalty = tickers.reduce((sum, t) => sum + (PENALTY[t] ?? 0), 0);
  const stars = Math.max(0, Math.min(3, 3 - totalPenalty));
  return stars; // 0..3
};


// Function to convert COGC program type to readable format
const formatCOGCProgram = (programType) => {
  if (!programType) return 'No active Program';
  return programType.split('_').map(word => word.charAt(0) + word.slice(1).toLowerCase()).join(' ');
};

// Function to create PlanetTier indicator
const createPlanetTierIndicator = (starCount) => {
  const total = 3;
  const filledStar = '';
  const emptyStar = '';
  const filled = Math.max(0, Math.min(total, starCount|0));
  const stars = filledStar.repeat(filled) + emptyStar.repeat(total - filled);
  return `<span class="planet-tier">${stars}</span>`;
};

// Function to create and show the info panel
const showInfoPanel = (rect, x, y, searchResults, materials, isRelativeThreshold, selectedCogcProgram) => {
  const isPlanetInSearchResults = (planetId) => {
    return searchResults.some(result =>
      (result.type === 'planet' && result.planetId === planetId) ||
      (result.type === 'material' && result.planetId === planetId)
    );
  };

  const findMatchingMaterials = (planetId) => {
    return searchResults.filter(result =>
      result.type === 'material' && result.planetId === planetId
    );
  };

  const createConcentrationBar = (concentration, materialId, resourceType, isRelative, maxConcentrations) => {
    const key = `${materialId}-${resourceType}`;
    const maxConcentration = maxConcentrations[key] || concentration;
    const percentage = isRelative ? (concentration / maxConcentration) * 100 : concentration * 100;
    const hue = (percentage / 100) * 120; // 0 is red, 120 is green
    const backgroundColor = `hsl(${hue}, 100%, 50%)`;

    return `
    <div class="concentration-bar-container" style="width: 100px; background-color: #ddd; height: 10px; margin-left: 5px;">
      <div class="concentration-bar" style="width: ${percentage}%; background-color: ${backgroundColor}; height: 100%;"></div>
    </div>
    <span class="resource-percentage">${percentage.toFixed(2)}%</span>
  `;
  };


  const systemId = rect.attr('id').replace('#', '');
  const system = universeData ? universeData[systemId] : null;
  const planets = planetData ? planetData[systemId] : null;

  if (!system || !planets) {
    console.error('System or planet data not found for:', systemId);
    return;
  }

  const infoPanel = d3.select('body').append('div')
    .attr('class', 'info-panel')
    .style('left', `${x}px`)
    .style('top', `${y}px`)
    .style('display', 'block');

  let content = `<h3>${system.Name} (${system.NaturalId})</h3>`;
  content += `<ul class="planet-list">`;

  // Sort planets alphabetically by PlanetNaturalId
  const sortedPlanets = planets.sort((a, b) => a.PlanetNaturalId.localeCompare(b.PlanetNaturalId));

  sortedPlanets.forEach(planet => {
    let planetTier = determinePlanetTier(planet.BuildRequirements);
    const isHighlighted = isPlanetInSearchResults(planet.PlanetNaturalId);
    const matchingMaterials = findMatchingMaterials(planet.PlanetNaturalId);

    content += `<li class="${isHighlighted ? 'highlighted-planet' : ''}">
      <div class="planet-info">
        <div class="planet-name-tier">
          <span class="planet-name">${planet.PlanetName} (${planet.PlanetNaturalId})</span>
          ${createPlanetTierIndicator(planetTier)}
        </div>
        <div class="facility-indicators">
          ${createFacilityIndicator(planet.HasLocalMarket, BadgeCent)}
          ${createFacilityIndicator(planet.HasChamberOfCommerce, Globe)}
          ${createFacilityIndicator(planet.HasWarehouse, Truck)}
          ${createFacilityIndicator(planet.HasAdministrationCenter, BookOpen)}
          ${createFacilityIndicator(planet.HasShipyard, Anchor)}
        </div>
      </div>`;
    if (planet.HasChamberOfCommerce) {
      let programType = null;
      if (planet.COGCPrograms.length > 0) {
        const programs = planet.COGCPrograms;
        const sortedPrograms = programs.sort((a, b) => b.StartEpochMs - a.StartEpochMs);
        const currentProgram = sortedPrograms[1] || sortedPrograms[0] || null;
        programType = currentProgram ? currentProgram.ProgramType : null;
      }
      const formattedProgram = formatCOGCProgram(programType);
      
      // Check if this program matches the selection
      const isCogcMatch = selectedCogcProgram && programType === selectedCogcProgram;
      const style = isCogcMatch ? 'color: #f7a600; font-weight: bold;' : '';
      
      content += `<div class="cogc-program" style="${style}">CoGC: ${formattedProgram}</div>`;
    }
    // Add resource bars for matching materials
    if (matchingMaterials.length > 0) {
      content += `<div class="matching-resources">`;
      matchingMaterials.forEach(material => {
        const materialInfo = materials.find(m => m.MaterialId === material.id);
        const planetResource = planet.Resources.find(r => r.MaterialId === material.id);
        if (materialInfo && planetResource) {
          content += `
            <div class="resource-item" style="display: flex; align-items: center; margin-bottom: 5px;">
              <span class="resource-name" style="margin-right: 5px;">${materialInfo.Ticker}</span>
              ${createConcentrationBar(
                planetResource.Factor,
                planetResource.MaterialId,
                planetResource.ResourceType,
                isRelativeThreshold,
                universeMaxConcentrations
              )}
            </div>
          `;
        }
      });
      content += `</div>`;
    }
    content += `</li>`;
  });

  content += `</ul>`;
  infoPanel.html(content);
};

// Function to hide the info panel
const hideInfoPanel = () => {
  d3.select('.info-panel').remove();
};

// Function to add mouseover and mouseout events for animation
export const addMouseEvents = (g, searchResults, materials, isRelativeThreshold, selectedCogcProgram) => {
  g.selectAll('rect').each(function() {
    const rect = d3.select(this);
    const originalSize = { width: +rect.attr('width'), height: +rect.attr('height') };
    const originalPos = { x: +rect.attr('x'), y: +rect.attr('y') };
    let hoverTimer;
    let overlayOriginalSize, overlayOriginalPos;

    rect.on('mouseover.system', function(event) {
      if (rect.attr('id') === 'rect1' || d3.select(event.target).classed('data-overlay')) return;
      rect
        .attr('fill-opacity', 1)
        .attr('stroke-opacity', 1)
        .transition()
        .duration(200)
        .attr('width', originalSize.width * 2)
        .attr('height', originalSize.height * 2)
        .attr('x', originalPos.x - originalSize.width / 2)
        .attr('y', originalPos.y - originalSize.height / 2);

      const overlayRect = rect.property('cogcOverlayRect');

      if (overlayRect) {
        overlayOriginalSize = {
          width: +overlayRect.attr('width'),
          height: +overlayRect.attr('height')
        };
        overlayOriginalPos = {
          x: +overlayRect.attr('x'),
          y: +overlayRect.attr('y')
        };

        overlayRect
          .transition()
          .duration(200)
          .attr('width', overlayOriginalSize.width + originalSize.width)
          .attr('height', overlayOriginalSize.height + originalSize.width)
          .attr('x', overlayOriginalPos.x - originalSize.width / 2)
          .attr('y', overlayOriginalPos.y - originalSize.height / 2);
      }

      // Set timer for info panel
      hoverTimer = setTimeout(() => {
        const [x, y] = d3.pointer(event);
        showInfoPanel(rect, x, y, searchResults, materials, isRelativeThreshold, selectedCogcProgram);
      }, 400);

    }).on('mouseout.system', function(event) {
      if (rect.attr('id') === 'rect1') return;
      rect.transition()
        .duration(200)
        .attr('width', originalSize.width)
        .attr('height', originalSize.height)
        .attr('x', originalPos.x)
        .attr('y', originalPos.y)
        .attr('fill-opacity', rect.classed('search-highlight') ? 1 : colors.resetSystemFillOpacity);

      // Reset the overlay rect if it exists
      const overlayRect = rect.property('cogcOverlayRect');
      if (overlayRect) {
        overlayRect
          .transition()
          .duration(200)
          .attr('width', overlayOriginalSize.width)
          .attr('height', overlayOriginalSize.height)
          .attr('x', overlayOriginalPos.x)
          .attr('y', overlayOriginalPos.y);
      }

      // Clear timer and hide info panel
      clearTimeout(hoverTimer);
      hideInfoPanel();
    });
  });
};

--- FILE: src/components/DataPointOverlay.jsx ---

import React, { useEffect, useCallback } from 'react';
import * as d3 from 'd3';
import { useDataPoints } from '../contexts/DataPointContext';

const DataPointOverlay = ({ mapRef }) => {
  const {
    meteorDensityData,
    luminosityData,
    systemNames,
    isOverlayVisible,
    isLoading,
    error,
    maxValues
  } = useDataPoints();

  const renderOverlay = useCallback(() => {
    if (!mapRef?.current?.g) return;

    // Clean up existing elements
    mapRef.current.g.selectAll('.meteor-density-group').remove();
    mapRef.current.g.selectAll('.system-name-label').remove();

    if (!isOverlayVisible || isLoading || error) {
      return;
    }

    const { g } = mapRef.current;
    const transform = d3.zoomTransform(g.node());
    const zoomLevel = transform?.k || 1;

    // Color scales for both metrics
    const densityColorScale = d3.scaleSequential()
      .domain([0, maxValues.density])
      .interpolator(d3.interpolatePuBu);

    const luminosityColorScale = d3.scaleSequential()
      .domain([0, maxValues.luminosity])
      .interpolator(d3.interpolateWarm);

    g.selectAll('rect:not(.meteor-density-bar)').each(function() {
      const node = d3.select(this);
      const systemId = node.attr('id');

      if (systemId === 'rect1') return;

      const density = meteorDensityData[systemId] || 0;
      const luminosity = luminosityData[systemId] || 0;

      const nodeWidth = parseFloat(node.attr('width'));
      const nodeHeight = parseFloat(node.attr('height'));
      const nodeX = parseFloat(node.attr('x'));
      const nodeY = parseFloat(node.attr('y'));

      const systemGroup = g.append('g')
        .attr('class', 'meteor-density-group');

      // Calculate bar dimensions
      const barWidth = Math.max(3, nodeWidth * 0.2 / zoomLevel);
      const maxBarHeight = nodeHeight;
      const barSpacing = barWidth * 0.5;

      // Create log scale for luminosity bar height
      const luminosityLogScale = d3.scaleLog()
        .domain([0.01, maxValues.luminosity]) // Using 0.1 as minimum to avoid log(0)
        .range([0, maxBarHeight]);

      // Density bar
      const densityHeight = maxBarHeight * (density / maxValues.density);
      const densityX = nodeX + nodeWidth * 1.2;

      // Background for density bar
      systemGroup.append('rect')
        .attr('class', 'meteor-density-bar-background data-overlay')
        .attr('x', densityX)
        .attr('y', nodeY)
        .attr('width', barWidth)
        .attr('height', maxBarHeight)
        .attr('fill', '#2a2a2a')
        .attr('opacity', 0.5);

      // Density bar
      const densityBar = systemGroup.append('rect')
        .attr('class', 'meteor-density-bar data-overlay')
        .attr('x', densityX)
        .attr('y', nodeY + maxBarHeight - densityHeight)
        .attr('width', barWidth)
        .attr('height', densityHeight)
        .attr('fill', densityColorScale(density))
        .attr('opacity', 0.8);

      // Luminosity bar
      const luminosityHeight = luminosityLogScale(Math.max(0.1, luminosity));
      const luminosityX = densityX + barWidth + barSpacing;

      // Background for luminosity bar
      systemGroup.append('rect')
        .attr('class', 'luminosity-bar-background data-overlay')
        .attr('x', luminosityX)
        .attr('y', nodeY)
        .attr('width', barWidth)
        .attr('height', maxBarHeight)
        .attr('fill', '#2a2a2a')
        .attr('opacity', 0.5);

      // Luminosity bar
      const luminosityBar = systemGroup.append('rect')
        .attr('class', 'luminosity-bar data-overlay')
        .attr('x', luminosityX)
        .attr('y', nodeY + maxBarHeight - luminosityHeight)
        .attr('width', barWidth)
        .attr('height', luminosityHeight)
        .attr('fill', luminosityColorScale(luminosity))
        .attr('opacity', 0.8);

      // System name label
      systemGroup.append('text')
        .attr('class', 'system-name-label data-overlay')
        .attr('x', nodeX + (nodeWidth / 2))
        .attr('y', nodeY + nodeHeight + 2)
        .attr('fill', '#CCCCCC')
        .attr('stroke', '#000000')
        .attr('stroke-width', 1 / zoomLevel)
        .attr('paint-order', 'stroke')
        .attr('font-size', '6px')
        .attr('text-anchor', 'middle')
        .attr('dominant-baseline', 'hanging')
        .style('pointer-events', 'none')
        .text(systemNames[systemId] || systemId);

      // Add hover interactions for both bars
      const addBarHoverEffects = (bar, dataType, value, colorScale) => {
        bar.on('mouseover.data', function(event) {
          event.stopPropagation();
          d3.select(this)
            .attr('opacity', 1)
            .attr('stroke', '#ffffff')
            .attr('stroke-width', 1 / zoomLevel);

          d3.select('body')
            .append('div')
            .attr('class', 'data-overlay-tooltip')
            .style('position', 'absolute')
            .style('left', `${event.pageX + 10}px`)
            .style('top', `${event.pageY - 10}px`)
            .style('background-color', 'rgba(0, 0, 0, 0.8)')
            .style('color', 'white')
            .style('padding', '5px')
            .style('border-radius', '4px')
            .style('font-size', '12px')
            .style('pointer-events', 'none')
            .html(`
              <div style="background: rgba(0,0,0,0.9); padding: 8px; border-radius: 4px; border: 1px solid #444">
                <div style="font-weight: bold; color: #f7a600; margin-bottom: 4px">${systemNames[systemId] || systemId}</div>
                <div>${dataType}: ${value.toFixed(3)}</div>
                <div style="color: #aaa; font-size: 11px; margin-top: 2px">
                  Relative to Max (${maxValues[dataType.toLowerCase()].toFixed(2)}):
                  ${((value / maxValues[dataType.toLowerCase()]) * 100).toFixed(1)}%
                </div>
              </div>
            `);
        })
        .on('mouseout.data', function(event) {
          event.stopPropagation();
          d3.select(this)
            .attr('opacity', 0.8)
            .attr('stroke', 'none');
          d3.selectAll('.data-overlay-tooltip').remove();
        });
      };

      addBarHoverEffects(densityBar, 'Density', density, densityColorScale);
      addBarHoverEffects(luminosityBar, 'Luminosity', luminosity, luminosityColorScale);
    });
  }, [mapRef, isOverlayVisible, isLoading, error, meteorDensityData, luminosityData, systemNames, maxValues]);

  useEffect(() => {
    renderOverlay();
  }, [renderOverlay]);

  useEffect(() => {
    if (!mapRef?.current?.svg) return;

    // Capture the current svg reference
    const svg = mapRef.current.svg;

    const handleZoom = () => {
      renderOverlay();
    };

    svg.on('zoom.overlay', handleZoom);

    return () => {
      // Use the captured reference in cleanup
      svg.on('zoom.overlay', null);
    };
  }, [mapRef, renderOverlay]);

  return null;
};

export default React.memo(DataPointOverlay);

--- FILE: src/components/FilterCategories.css ---

.toggle-token {
  font-size: 12px;
  padding: 5px 9px;
  margin: 2px;
  border: 1px solid #ccc;
  border-radius: 15px;
  background-color: #f0f0f0;
  color: #333;
  cursor: pointer;
  transition: all 0.3s ease;
  position: relative;
}

.toggle-token1 {
  padding: 5px 3px 5px 9px;
  border-radius: 15px 0px 0px 15px;
  margin: 2px 1px 2px 2px;
}

.toggle-token2 {
  padding: 5px 9px 5px 3px;
  border-radius: 0px 15px 15px 0px;
  margin: 2px 2px 2px 1px;
}

.toggle-token.active {
  background-color: #f7a600;
  color: white;
  border-color: #f7a600;
}

.filter-category select {
  padding: 5px 10px 5px 3px;
  border-radius: 0px 15px 15px 0px;
  margin: 2px 2px 2px 1px;
  border: 1px solid #ccc;
  background-color: #f0f0f0;
  color: #333;
  font-size: 12px;
  cursor: pointer;
  transition: all 0.3s ease;
}

.filter-category select:hover {
  border-color: #999;
}

.filter-category select:focus {
  outline: none;
  border-color: #f7a600;
  box-shadow: 0 0 0 2px rgba(247, 166, 0, 0.2);
}

.toggle-group {
  display: flex;
  flex-wrap: wrap;
}

.toggle-token:hover::after {
  content: attr(data-tooltip);
  position: absolute;
  bottom: -100%;
  left: 50%;
  transform: translateX(-50%);
  background-color: #333;
  color: white;
  padding: 5px 10px;
  border-radius: 4px;
  font-size: 12px;
  white-space: nowrap;
  z-index: 1000;
  pointer-events: none;
}

.pathfinding-toggle-container .toggle-token[data-tooltip]::after {
  position: absolute;
  left: 30%;
  bottom: -200%;
  width: max-content;
  max-width: 125px;
  white-space: pre-wrap;
}

.resource-threshold-input {
  width: 50px;
  padding: 5px;
  margin-right: 5px;
  border: 1px solid #ccc;
  border-radius: 14px;
  background-color: #333;
  color: #fff;
}

.resource-threshold-value {
  font-size: 14px;
  color: #f7a600;
}

.resource-threshold-controls {
  display: flex;
  align-items: center;
  gap: 10px;
}

.resource-type-filter select {
  padding: 5px;
  border-radius: 15px;
  border: 1px solid #ccc;
  background-color: #333;
  color: #fff;
  font-size: 12px;
}

@media (max-width: 820px) {
  .toggle-token {
    font-size: 10px;
    padding: 2px 5px;
  }

  .toggle-token:hover::after {
    font-size: 10px;
    padding: 3px 6px;
  }

  .filter-category select {
    padding: 2px 5px;
    border-radius: 13px;
    font-size: 10px;
  }

  .resource-threshold-input {
    width: 50px;
    padding: 3px;
    font-size: 10px;
  }

  .resource-threshold-value {
    font-size: 10px;
  }

  .resource-threshold-controls {
    flex-wrap: wrap;
  }
}

--- FILE: src/components/FilterCategories.jsx ---

import React, { useContext, useState } from 'react';
import { SearchContext } from '../contexts/SearchContext';
import { useCogcOverlay } from '../contexts/CogcOverlayContext';
import { cogcPrograms } from '../constants/cogcPrograms';
import ResourceThresholdFilter from './ResourceThresholdFilter';

const ToggleToken = ({ label, active, onClick, tooltip, className }) => (
  <button
    className={`toggle-token ${active ? 'active' : ''} ${className}`}
    onClick={onClick}
    data-tooltip={tooltip}
  >
    {label}
  </button>
);

const FilterCategory = ({ title, options, mouseoverText, selectedOptions, onChange }) => (
  <div className="filter-category">
    <h4>{title}</h4>
    <div className="toggle-group">
      {options.map((option, index) => (
        <ToggleToken
          key={option}
          label={option}
          active={selectedOptions.includes(option)}
          onClick={() => onChange(option)}
          tooltip={mouseoverText[index] || option}
          className={`toggle-token${index + 1}`}
        />
      ))}
    </div>
  </div>
);

const CogcFilter = ({ active, program, onToggle, onProgramChange }) => {
  const { setOverlayProgram } = useCogcOverlay();

  const handleProgramChange = (value) => {
    onProgramChange(value);
    if (value !== 'ALL' && value !== null) {
      setOverlayProgram(value);
    } else {
      setOverlayProgram(null);
    }
  };

  return (
    <div className="filter-category">
      <h4>Cogc Program</h4>
      <div className="cogc-filter-controls">
        <ToggleToken
          label="Cogc"
          active={active}
          onClick={onToggle}
          tooltip="Toggle Cogc Program filter, dropdown activates an overlay"
          className={`toggle-token1`}
        />
        <select
          value={program}
          onChange={(e) => handleProgramChange(e.target.value)}
        >
          {cogcPrograms.map((program) => (
            <option key={program.value} value={program.display}>
              {program.display}
            </option>
          ))}
        </select>
      </div>
    </div>
  );
};

const FilterCategories = () => {
  const { filters, updateFilters } = useContext(SearchContext);
  const [cogcActive, setCogcActive] = useState(false);
  const { overlayProgram } = useCogcOverlay();

  const handleChange = (category, option) => {
    const newFilters = {
      ...filters,
      [category]: filters[category].includes(option)
        ? filters[category].filter(item => item !== option)
        : [...filters[category], option]
    };
    updateFilters(newFilters);
  };

  const handleCogcToggle = (value) => {
    setCogcActive(!cogcActive);
    if (!cogcActive) {
      // Find the corresponding value for the current overlayProgram
      const programObject = cogcPrograms.find(program => program.display === overlayProgram);
      let programValue;

      if (programObject) {
        programValue = programObject.value;
      } else if (overlayProgram === null || overlayProgram === undefined) {
        programValue = 'ALL'; // Default to 'ALL' if no overlay program is set
      } else {
        console.warn(`No matching program found for: ${overlayProgram}`);
        programValue = 'ALL'; // Default to 'ALL' if no match is found
      }
      updateFilters({ ...filters, cogcProgram: [programValue] });
    } else {
      updateFilters({ ...filters, cogcProgram: [] });
    }
  };

  const handleCogcProgramChange = (value) => {
      if(cogcActive) {
        const valueToSet = cogcPrograms.find(program => program.display === value);
        updateFilters({ ...filters, cogcProgram: [valueToSet.value] });
      } else {
        updateFilters({ ...filters, cogcProgram: [] });
      }

  };

  return (
    <div className="filter-categories">
      <FilterCategory
        title="Planet Type"
        options={['Rocky', 'Gaseous', 'Fertile']}
        mouseoverText={['MCG', 'AEF', 'Fertile Planets']}
        selectedOptions={filters.planetType}
        onChange={option => handleChange('planetType', option)}
      />
      <FilterCategory
        title="Gravity"
        options={['Low', 'High']}
        mouseoverText={['MGC', 'BL']}
        selectedOptions={filters.gravity}
        onChange={option => handleChange('gravity', option)}
      />
      <FilterCategory
        title="Temperature"
        options={['Low', 'High']}
        mouseoverText={['INS', 'TSH']}
        selectedOptions={filters.temperature}
        onChange={option => handleChange('temperature', option)}
      />
      <FilterCategory
        title="Pressure"
        options={['Low', 'High']}
        mouseoverText={['SEA', 'HSE']}
        selectedOptions={filters.pressure}
        onChange={option => handleChange('pressure', option)}
      />
      <CogcFilter
        active={cogcActive}
        onToggle={handleCogcToggle}
        onProgramChange={handleCogcProgramChange}
      />
      <ResourceThresholdFilter />
    </div>
  );
};

export default FilterCategories;

--- FILE: src/components/GatewayControls.jsx ---

import React from 'react';
import { useMapMode, GATEWAY_STRATEGIES } from '../contexts/MapModeContext';

const GatewayControls = () => {
  const { gatewayData, setGatewayStrategy, clearGatewaySelections } = useMapMode();

  return (
    <div className="gateway-controls" style={{ display: 'flex', gap: '15px', alignItems: 'center' }}>
      <div className="strategy-toggle" style={{ display: 'flex', background: '#333', borderRadius: '15px', padding: '2px' }}>
        <button 
          className={`toggle-token ${gatewayData.strategy === GATEWAY_STRATEGIES.SINGLE ? 'active' : ''}`}
          onClick={() => setGatewayStrategy(GATEWAY_STRATEGIES.SINGLE)}
          style={{ margin: 0, borderRadius: '15px 0 0 15px', borderRight: 'none' }}
        >
          Single Origin
        </button>
        <button 
           className={`toggle-token ${gatewayData.strategy === GATEWAY_STRATEGIES.DUAL ? 'active' : ''}`}
           onClick={() => setGatewayStrategy(GATEWAY_STRATEGIES.DUAL)}
           style={{ margin: 0, borderRadius: '0 15px 15px 0' }}
        >
          Dual Origin (Midpoint)
        </button>
      </div>
      
      <button className="clear-button" onClick={clearGatewaySelections}>
        Clear Selection
      </button>
    </div>
  );
};

export default GatewayControls;

--- FILE: src/components/InfoTooltip.jsx ---

import React, { useState } from 'react';
import { Info, BadgeCent, Globe, Truck, BookOpen, Anchor, Earth, Cloud } from 'lucide-react';

const InfoTooltip = () => {
  const [isTooltipVisible, setIsTooltipVisible] = useState(false);

  return (
    <div className="info-tooltip-container" style={{ position: 'relative' }}>
      <Info
        size={24}
        color="#f7a600"
        style={{ cursor: 'pointer' }}
        onMouseEnter={() => setIsTooltipVisible(true)}
        onMouseLeave={() => setIsTooltipVisible(false)}
      />
      {isTooltipVisible && (
        <div className="tooltip" style={{
          position: 'absolute',
          top: '100%',
          right: 0,
          backgroundColor: '#333',
          color: 'white',
          padding: '10px',
          borderRadius: '4px',
          boxShadow: '0 2px 5px rgba(0,0,0,0.2)',
          width: '300px',
          zIndex: 1000,
          border: '2px solid #222222',
        }}>
          <h4 style={{ margin: '0 0 10px 0' }}>Symbol Legend</h4>
          <h5 style={{ margin: '10px 0 5px 0' }}>Planet Types:</h5>
          <ul style={{ padding: 0, margin: 0, listStyle: 'none' }}>
            <li><Earth size={16} style={{marginRight: '5px', color: '#f7a600'}} /> Rocky Planet</li>
            <li><Cloud size={16} style={{marginRight: '5px', color: '#f7a600'}} /> Gas Giant</li>
          </ul>
          <h5 style={{ margin: '10px 0 5px 0' }}>Resources:</h5>
          <ul style={{ padding: 0, margin: 0, listStyle: 'none' }}>
            <li> - Mineral resource</li>
            <li> - Gaseous resource</li>
            <li> - Liquid resource</li>
          </ul>
          <h5 style={{ margin: '10px 0 5px 0' }}>Facilities:</h5>
          <ul style={{ padding: 0, margin: 0, listStyle: 'none' }}>
            <li><BadgeCent size={16} style={{marginRight: '5px', color: '#f7a600'}} /> - Local Market</li>
            <li><Globe size={16} style={{marginRight: '5px', color: '#f7a600'}} /> - Chamber of Commerce</li>
            <li><Truck size={16} style={{marginRight: '5px', color: '#f7a600'}} /> - Warehouse</li>
            <li><BookOpen size={16} style={{marginRight: '5px', color: '#f7a600'}} /> - Administration Center</li>
            <li><Anchor size={16} style={{marginRight: '5px', color: '#f7a600'}} /> - Shipyard</li>
          </ul>
          <h5 style={{ margin: '10px 0 5px 0' }}>Planet Rating:</h5>
          <ul style={{ padding: 0, margin: 0, listStyle: 'none' }}>
            <li>Start at <strong>3</strong>. Deduct stars by environment penalties.</li>
            <li>Penalties:</li>
            <ul style={{ paddingLeft: '16px', margin: '4px 0', listStyle: 'circle' }}>
              <li><code>MCG</code>,<code>SEA</code>: 0</li>
              <li><code>BL</code>, <code>INS</code>, <code>HSE</code>, <code>AEF</code>: 1</li>
              <li><code>MGC</code>, <code>TSH</code>: 2</li>
            </ul>
          </ul>

          <p style={{ margin: '8px 0 0 0' }}>
            Examples:
            <br/> <code>HSE</code>: 3  1 = <strong>2</strong>
            <br/> <code>HSE+INS</code>: 3  (1+1) = <strong>1</strong>
            <br/> <code>MGC</code>: 3  2 = <strong>1</strong>
            <br/> <code>TSH+HSE</code>: 3  (2+1) = <strong>0</strong>
            <br/> <code>SEA</code> or <code>MCG</code> only: <strong>3</strong>
          </p>
        </div>
      )}
    </div>
  );
};

export default InfoTooltip;

--- FILE: src/components/LayersMenu.jsx ---

import React, { useState } from 'react';
import { Layers } from 'lucide-react';
import MeteorDensityToggle from './MeteorDensityToggle';
// Import other visual toggles here

const LayersMenu = () => {
  const [isOpen, setIsOpen] = useState(false);

  return (
    <div className="layers-menu-container">
      <button 
        className={`layers-btn ${isOpen ? 'active' : ''}`} 
        onClick={() => setIsOpen(!isOpen)}
        title="Map Layers"
      >
        <Layers size={20} />
      </button>
      
      {isOpen && (
        <div className="layers-dropdown">
           <h4>Overlays</h4>
           <div className="layer-item">
             <MeteorDensityToggle /> {/* Refactor this component to lose its wrapper div if needed */}
           </div>
           {/* Add Future "Show Existing Gateways" toggle here */}
           
           {/* You could even move the CoGC dropdown here! */}
        </div>
      )}
    </div>
  );
};

export default LayersMenu;

--- FILE: src/components/MaterialSearchField.jsx ---

import React, { useState, useContext } from 'react';
import { SearchContext } from '../contexts/SearchContext';

const MaterialSearchField = () => {
  const [notification, setNotification] = useState('');
  const { handleMaterialSearch, materialSearchTerm, updateMaterialSearchTerm } = useContext(SearchContext);

  const onSearch = (e) => {
    e.preventDefault();
    const result = handleMaterialSearch(materialSearchTerm);
    if (result.length === 0) {
      setNotification('No matches found');
      setTimeout(() => setNotification(''), 3000); // Clear notification after 3 seconds
    } else {
      setNotification('');
    }
  };

  return (
    <div className="material-search-field">
      <form onSubmit={onSearch}>
        <input
          type="text"
          value={materialSearchTerm}
          onChange={(e) => updateMaterialSearchTerm(e.target.value)}
          placeholder="Search resource, filters..."
        />
        <button type="submit" className="search-button material-search">Search</button>
      </form>
      {notification && <div className="search-notification">{notification}</div>}
    </div>
  );
};

export default MaterialSearchField;

--- FILE: src/components/MeteorDensityToggle.jsx ---

import React from 'react';
import { useDataPoints } from '../contexts/DataPointContext';

const MeteorDensityToggle = () => {
  const { isOverlayVisible, toggleOverlayVisibility } = useDataPoints();

  return (
    <div className="meteor-density-toggle">
      <button
        className={`toggle-token ${isOverlayVisible ? 'active' : ''}`}
        onClick={toggleOverlayVisibility}
        data-tooltip="Toggle overlay with meteor density and system names"
      >
      </button>
    </div>
  );
};

export default MeteorDensityToggle;

--- FILE: src/components/ModeSwitcher.jsx ---

import React from 'react';
import { useMapMode, MAP_MODES } from '../contexts/MapModeContext';
import { MousePointer2, Route, Plane } from 'lucide-react'; // Example icons

const ModeSwitcher = () => {
  const { activeMode, setActiveMode } = useMapMode();

  return (
    <div className="mode-switcher">
      <button 
        className={`mode-btn ${activeMode === MAP_MODES.EXPLORE ? 'active' : ''}`}
        onClick={() => setActiveMode(MAP_MODES.EXPLORE)}
        title="Explore Mode"
      >
        <MousePointer2 size={16} />
        <span>Explore</span>
      </button>
      
      <button 
        className={`mode-btn ${activeMode === MAP_MODES.NAVIGATION ? 'active' : ''}`}
        onClick={() => setActiveMode(MAP_MODES.NAVIGATION)}
        title="Navigation (Pathfinding)"
      >
        <Route size={16} />
        <span>Nav</span>
      </button>
      
      <button 
        className={`mode-btn ${activeMode === MAP_MODES.GATEWAY ? 'active' : ''}`}
        onClick={() => setActiveMode(MAP_MODES.GATEWAY)}
        title="Gateway Planning"
      >
        <Plane size={16} /> {/* Or a Gateway Icon */}
        <span>Gateway</span>
      </button>
    </div>
  );
};

export default ModeSwitcher;

--- FILE: src/components/Node.jsx ---

// Example Node component for handling individual node interactions
import React from 'react';
import * as d3 from 'd3';

const Node = ({ id, x, y, width, height, fill, stroke }) => {
  useEffect(() => {
    const node = d3.select(`#${id}`);
    const originalSize = { width, height };
    const originalPos = { x, y };

    node.on('mouseover', function() {
      if (id === 'rect1') return;
      node
        .attr('fill-opacity', 1)
        .attr('stroke-opacity', 1)
        .transition()
        .duration(200)
        .attr('width', originalSize.width * 2)
        .attr('height', originalSize.height * 2)
        .attr('x', originalPos.x - originalSize.width / 2)
        .attr('y', originalPos.y - originalSize.height / 2);
    }).on('mouseout', function() {
      if (id === 'rect1') return;
      node.transition()
        .duration(200)
        .attr('width', originalSize.width)
        .attr('height', originalSize.height)
        .attr('x', originalPos.x)
        .attr('y', originalPos.y)
        .attr('fill-opacity', 0.8);
    });

    // Add click event if needed
  }, [id, x, y, width, height]);

  return null; // This component is for logic only
};

export default Node;


--- FILE: src/components/Path.jsx ---

// Example Path component for handling individual path interactions
import React from 'react';
import * as d3 from 'd3';

const Path = ({ id, stroke, strokeWidth }) => {
  useEffect(() => {
    const path = d3.select(`#${id}`);

    // Add interactions if needed
  }, [id, stroke, strokeWidth]);

  return null; // This component is for logic only
};

export default Path;


--- FILE: src/components/PathfindingToggle.jsx ---

import React, { useContext } from 'react';
import { SelectionContext } from '../contexts/SelectionContext';

const PathfindingToggle = () => {
  const { isPathfindingEnabled, togglePathfinding } = useContext(SelectionContext);

  return (
    <div className="pathfinding-toggle">
      <button
        className={`toggle-token ${isPathfindingEnabled ? 'active' : ''}`}
        onClick={togglePathfinding}
        data-tooltip="Toggle pathfinding mode"
      >
      </button>
    </div>
  );
};

export default PathfindingToggle;


--- FILE: src/components/ResourceThresholdFilter.jsx ---

import React, { useContext } from 'react';
import { SearchContext } from '../contexts/SearchContext';

const ToggleToken = ({ label, active, onClick, tooltip }) => (
  <button
    className={`toggle-token ${active ? 'active' : ''}`}
    onClick={onClick}
    data-tooltip={tooltip}
  >
    {label}
  </button>
);

const ResourceThresholdFilter = () => {
  const {
    resourceThreshold,
    setResourceThreshold,
    isRelativeThreshold,
    setIsRelativeThreshold,
    resourceTypeFilter,
    setResourceTypeFilter
  } = useContext(SearchContext);

  const handleThresholdChange = (event) => {
    const value = parseFloat(event.target.value);
    setResourceThreshold(isNaN(value) ? 0 : value);
  };

  const handleToggleChange = () => {
    setIsRelativeThreshold(!isRelativeThreshold);
  };

  const handleResourceTypeChange = (event) => {
    setResourceTypeFilter(event.target.value);
  };

  return (
    <div className="filter-category">
      <h4>Resource Filters</h4>
      <div className="resource-filter-controls">
        <div className="resource-threshold-controls">
          <input
            type="number"
            min="0"
            max="1"
            step="0.05"
            value={resourceThreshold}
            onChange={handleThresholdChange}
            className="resource-threshold-input"
          />
          <span className="resource-threshold-value">{(resourceThreshold * 100).toFixed(0)}%</span>
          <ToggleToken
            label="Relative"
            active={isRelativeThreshold}
            onClick={handleToggleChange}
            tooltip="Relative to highest concentration (on) or absolute percentage (off)"
          />
        </div>
        <div className="resource-type-filter">
          <select value={resourceTypeFilter} onChange={handleResourceTypeChange}>
            <option value="ALL">All Types</option>
            <option value="GASEOUS">Gaseous</option>
            <option value="MINERAL">Mineral</option>
            <option value="LIQUID">Liquid</option>
          </select>
        </div>
      </div>
    </div>
  );
};

export default ResourceThresholdFilter;

--- FILE: src/components/SearchField.jsx ---

import React, { useState, useContext } from 'react';
import { SearchContext } from '../contexts/SearchContext';

const SearchField = () => {
  const [notification, setNotification] = useState('');
  const {
    handleSystemSearch,
    handleCompanySearch,
    systemSearchTerm,
    companySearchTerm,
    updateSystemSearchTerm,
    updateCompanySearchTerm,
    isCompanySearch
  } = useContext(SearchContext);

  const onSearch = async (e) => {
    e.preventDefault();
    let result;
    if (isCompanySearch) {
      result = await handleCompanySearch(companySearchTerm);
    } else {
      result = handleSystemSearch(systemSearchTerm);
    }
    if (result.length === 0) {
      setNotification('No matches found');
      setTimeout(() => setNotification(''), 3000);
    } else {
      setNotification('');
    }
  };

  return (
    <div className="search-field">
      <form onSubmit={onSearch}>
        <input
          type="text"
          value={isCompanySearch ? companySearchTerm : systemSearchTerm}
          onChange={(e) => isCompanySearch ? updateCompanySearchTerm(e.target.value) : updateSystemSearchTerm(e.target.value)}
          placeholder={isCompanySearch ? "Search company code..." : "Search system, planet..."}
        />
        <button type="submit" className="search-button system-search">Search</button>
      </form>
      {notification && <div className="search-notification">{notification}</div>}
    </div>
  );
};

export default SearchField;

--- FILE: src/components/Sidebar.jsx ---

import React, { useState, useContext, useMemo, useRef } from 'react';
import ReactDOM from 'react-dom';
import { ChevronRight, ChevronLeft, Earth, Cloud, Thermometer, Gauge, Weight, Users, X } from 'lucide-react';
import { GraphContext } from '../contexts/GraphContext';
import { SearchContext } from '../contexts/SearchContext';
import { SelectionContext } from '../contexts/SelectionContext';
import { useCogcOverlay } from '../contexts/CogcOverlayContext';
import { useMapMode, MAP_MODES, GATEWAY_STRATEGIES } from '../contexts/MapModeContext';
import { cogcPrograms } from '../constants/cogcPrograms';
import { colors } from '../config/config';

// --- Reusing Existing Helper Components ---

const ResourceIcon = ({ type }) => {
  let icon = '';
  switch (type) {
    case 'MINERAL': icon = ''; break;
    case 'GASEOUS': icon = ''; break;
    case 'LIQUID': icon = ''; break;
    default: icon = ''; break;
  }
  return <span title={type}>{icon}</span>;
};

const PlanetTypeIcon = ({ isRocky, cogcProgram }) => {
  const [showTooltip, setShowTooltip] = useState(false);
  const iconRef = useRef(null);
  const [tooltipStyle, setTooltipStyle] = useState({});

  const IconComponent = isRocky ? Earth : Cloud;
  const typeText = isRocky ? "Rocky Planet" : "Gas Giant";

  const formatProgram = (prog) => {
    if (!prog) return '';
    return prog.split('_').map(word => word.charAt(0) + word.slice(1).toLowerCase()).join(' ');
  };

  const getAgeString = (timestamp) => {
    if (!timestamp) return '';
    const diffMs = Date.now() - timestamp;
    const days = diffMs / 86400000; 
    if (days < 0.1) return "Just now";
    return `${days.toFixed(1)} days ago`;
  };

  const handleMouseEnter = () => {
    if (iconRef.current) {
      const rect = iconRef.current.getBoundingClientRect();
      setTooltipStyle({
        position: 'fixed',
        top: rect.bottom + 5,
        left: rect.left,
        backgroundColor: '#333',
        color: 'white',
        padding: '10px',
        borderRadius: '4px',
        boxShadow: '0 4px 8px rgba(0,0,0,0.5)',
        border: '2px solid #222222',
        minWidth: '150px',
        zIndex: 2000,
        pointerEvents: 'none'
      });
    }
    setShowTooltip(true);
  };

  return (
    <>
      <div 
        ref={iconRef}
        className="planet-condition-icon" 
        onMouseEnter={handleMouseEnter}
        onMouseLeave={() => setShowTooltip(false)}
        style={{ display: 'inline-block', verticalAlign: 'middle', marginRight: '5px', cursor: 'help' }}
      >
        <IconComponent
          size={18}
          color="#f7a600"
          strokeWidth={1.5}
          style={{
            display: 'inline-block',
            verticalAlign: 'middle',
            width: '18px',
            height: '18px',
            color: '#f7a600',
            fill: 'none',
            stroke: 'currentColor',
          }}
        />
      </div>
      {showTooltip && ReactDOM.createPortal(
        <div className="tooltip" style={tooltipStyle}>
          <strong>{typeText}</strong>
          {cogcProgram && (
            <div style={{ marginTop: '5px', borderTop: '1px solid #555', paddingTop: '3px' }}>
              <span style={{ fontSize: '10px', color: '#aaa' }}>CoGC Program:</span><br/>
              <span style={{ color: '#f7a600' }}>{formatProgram(cogcProgram.ProgramType)}</span>
              <div style={{ fontSize: '10px', color: '#aaa', marginTop: '2px', fontStyle: 'italic' }}>
                Started: {getAgeString(cogcProgram.StartEpochMs)}
              </div>
            </div>
          )}
        </div>,
        document.body
      )}
    </>
  );
};

const PlanetConditionIcon = ({ condition, value, ticker }) => {
  const [showTooltip, setShowTooltip] = useState(false);
  let IconComponent;
  let tooltipContent;
  let iconColor;

  const isLow = (condition, value) => {
    switch (condition) {
      case 'gravity': return value < 0.25;
      case 'temperature': return value < -25.0;
      case 'pressure': return value < 0.25;
      default: return false;
    }
  };

  switch (condition) {
    case 'gravity':
      IconComponent = Weight;
      tooltipContent = `Gravity: ${value.toFixed(2)} (${ticker})`;
      iconColor = isLow(condition, value) ? '#6f6ff7' : '#f54c4c';
      break;
    case 'temperature':
      IconComponent = Thermometer;
      tooltipContent = `Temperature: ${value.toFixed(2)}C (${ticker})`;
      iconColor = isLow(condition, value) ? '#6f6ff7' : '#f54c4c';
      break;
    case 'pressure':
      IconComponent = Gauge;
      tooltipContent = `Pressure: ${value.toFixed(2)} atm (${ticker})`;
      iconColor = isLow(condition, value) ? '#6f6ff7' : '#f54c4c';
      break;
    default:
      return null;
  }

  return (
    <div
      className="planet-condition-icon"
      onMouseEnter={() => setShowTooltip(true)}
      onMouseLeave={() => setShowTooltip(false)}
    >
      <IconComponent size={16} color={iconColor} strokeWidth={1.5} />
      {showTooltip && (
        <div className="tooltip">{tooltipContent}</div>
      )}
    </div>
  );
};

const WorkforceIcon = ({ planetId, populationData }) => {
  const [showTooltip, setShowTooltip] = useState(false);
  const iconRef = useRef(null);
  const [tooltipPos, setTooltipPos] = useState({ top: 0, right: 0 });
  const data = populationData ? populationData[planetId] : null;

  if (!data) return null;

  const tiers = ['Pioneer', 'Settler', 'Technician', 'Engineer', 'Scientist'];
  let totalOpenJobs = 0;
  let totalUnemployed = 0;

  tiers.forEach(tier => {
    const tierData = data.Workforce[tier];
    if (tierData) {
      totalOpenJobs += tierData.OpenJobs;
      totalUnemployed += tierData.Unemployed;
    }
  });

  const totalPop = tiers.reduce((sum, tier) => sum + (data.Workforce[tier]?.Population || 0), 0);
  if (totalPop <= 10) return null;

  let iconColor = '#888888'; 
  if (totalOpenJobs > 0) iconColor = '#f54c4c';
  else if (totalUnemployed > 0) iconColor = '#66ff66';

  const getAgeString = (timestamp) => {
    const diffMs = Date.now() - timestamp;
    const days = diffMs / 86400000;
    if (days < 0.1) return "Just now";
    return `${days.toFixed(1)} days ago`;
  };

  const handleMouseEnter = () => {
    if (iconRef.current) {
      const rect = iconRef.current.getBoundingClientRect();
      setTooltipPos({
        top: rect.bottom + 5, 
        right: window.innerWidth - rect.right 
      });
    }
    setShowTooltip(true);
  };

  return (
    <>
      <div
        ref={iconRef}
        className="planet-condition-icon"
        style={{ marginLeft: '8px', cursor: 'pointer' }}
        onMouseEnter={handleMouseEnter}
        onMouseLeave={() => setShowTooltip(false)}
        onClick={() => setShowTooltip(!showTooltip)}
      >
        <Users size={16} color={iconColor} strokeWidth={1.5} />
      </div>
      
      {showTooltip && ReactDOM.createPortal(
        <div className="tooltip" style={{ 
          minWidth: '230px', 
          textAlign: 'left', 
          backgroundColor: '#222', 
          border: '1px solid #444',
          zIndex: 2000,
          position: 'fixed',
          top: tooltipPos.top,
          right: tooltipPos.right,
          pointerEvents: 'none',
          boxShadow: '0 4px 6px rgba(0,0,0,0.3)'
        }}>
          <div style={{ 
            borderBottom: '1px solid #444', 
            paddingBottom: '5px', 
            marginBottom: '5px', 
            fontSize: '11px', 
            color: '#aaa',
            display: 'flex',
            justifyContent: 'space-between'
          }}>
            <span>Population: {totalPop.toLocaleString()}</span>
            <span style={{ fontStyle: 'italic' }}>{getAgeString(data.Timestamp)}</span>
          </div>

          <div style={{ display: 'flex', fontSize: '10px', color: '#888', marginBottom: '2px' }}>
            <span style={{ flex: 1 }}>Tier</span>
            <span style={{ width: '65px', textAlign: 'right' }}>Unemployed</span>
            <span style={{ width: '60px', textAlign: 'right' }}>Open Jobs</span>
          </div>

          {tiers.map(tier => {
            const wf = data.Workforce[tier];
            if (!wf || (wf.Population === 0 && wf.OpenJobs === 0)) return null;
            const hasUnemployment = wf.Unemployed > 0;
            const hasOpenJobs = wf.OpenJobs > 0;

            return (
              <div key={tier} style={{ display: 'flex', fontSize: '11px', marginBottom: '2px' }}>
                <span style={{ flex: 1, color: '#ddd' }}>{tier}</span>
                <span style={{ 
                  width: '65px', 
                  textAlign: 'right', 
                  color: hasUnemployment ? '#66ff66' : '#444',
                  fontWeight: hasUnemployment ? 'bold' : 'normal'
                }}>
                  {wf.Unemployed > 0 ? wf.Unemployed : '-'}
                </span>
                <span style={{ 
                  width: '60px', 
                  textAlign: 'right', 
                  color: hasOpenJobs ? '#f54c4c' : '#444',
                  fontWeight: hasOpenJobs ? 'bold' : 'normal'
                }}>
                  {wf.OpenJobs > 0 ? wf.OpenJobs : '-'}
                </span>
              </div>
            );
          })}
        </div>,
        document.body
      )}
    </>
  );
};

const GatewayLegend = () => (
    <div className="gateway-legend">
      <h4>Distance Legend (pc)</h4>
      <div className="legend-items">
        <div className="legend-item"><span className="color-box" style={{background: colors.gateway.under10}}></span> &lt; 10</div>
        <div className="legend-item"><span className="color-box" style={{background: colors.gateway.under15}}></span> 10 - 15</div>
        <div className="legend-item"><span className="color-box" style={{background: colors.gateway.under20}}></span> 15 - 20</div>
        <div className="legend-item"><span className="color-box" style={{background: colors.gateway.under25}}></span> 20 - 25</div>
        <div className="legend-item"><span className="color-box" style={{background: colors.gateway.over25}}></span> &gt; 25</div>
      </div>
    </div>
);

const Sidebar = () => {
  const [isCollapsed, setIsCollapsed] = useState(window.innerWidth < 768);
  const { universeData, planetData, materials, populationData } = useContext(GraphContext);
  const { selectedSystem } = useContext(SelectionContext);
  const { searchMaterial, searchResults, isRelativeThreshold, isCompanySearch } = useContext(SearchContext);
  const { activeMode, gatewayData, removePlannedGateway } = useMapMode();
  const { overlayProgram } = useCogcOverlay();
  
  const selectedProgramValue = cogcPrograms.find(program => program.display === overlayProgram)?.value;

  const toggleSidebar = () => setIsCollapsed(!isCollapsed);

  var materialsMap = [];
  if (materials && materials.length > 0) {
    materialsMap = materials.reduce((acc, material) => {
      acc[material.MaterialId] = material;
      return acc;
    }, {});
  }

  // --- Logic Helpers ---

  const getActiveCogc = (planet) => {
    if (!planet.COGCPrograms || planet.COGCPrograms.length === 0) return null;
    const sortedPrograms = [...planet.COGCPrograms].sort((a, b) => b.StartEpochMs - a.StartEpochMs);
    const relevantProgram = sortedPrograms[1] || sortedPrograms[0];
    return relevantProgram || null;
  };

  const isCardHighlighted = (planetId, planet) => {
    const isPlanetInSearchResults = searchResults.some(result =>
      (result.type === 'planet' && result.id === planetId) ||
      (result.type === 'company_base' && result.planetNaturalId === planetId)
    );
    if (selectedProgramValue) {
        const activeCogc = getActiveCogc(planet);
        if (activeCogc && activeCogc.ProgramType === selectedProgramValue) return true;
    }
    return isPlanetInSearchResults;
  };

  const isResourceHighlighted = (materialId, planetId) => {
    const isPlanetInSearchResults = searchResults.some(result =>
      (result.type === 'planet' && result.id === planetId) ||
      (result.type === 'material' && result.planetId === planetId) ||
      (result.type === 'company_base' && result.planetNaturalId === planetId)
    );
    const isMaterialInSearchMaterial = searchMaterial.includes(materialId);
    return (isMaterialInSearchMaterial && isPlanetInSearchResults) || (isCompanySearch && isPlanetInSearchResults);
  };

  const isConditionAbnormal = (condition, value) => {
    switch (condition) {
      case 'gravity': return value < 0.25 || value > 2.5;
      case 'temperature': return value < -25.0 || value > 75.0;
      case 'pressure': return value < 0.25 || value > 2.0;
      default: return false;
    }
  };

  const getConditionTicker = (condition, value) => {
    switch (condition) {
      case 'gravity': return value < 0.25 ? 'MGC' : 'BL';
      case 'temperature': return value < -25.0 ? 'INS' : 'TSH';
      case 'pressure': return value < 0.25 ? 'SEA' : 'HSE';
      default: return '';
    }
  };

  const maxConcentrations = useMemo(() => {
    const maxConc = {};
    if (planetData) {
      Object.values(planetData).flat().forEach(planet => {
        planet.Resources.forEach(resource => {
          const key = `${resource.MaterialId}-${resource.ResourceType}`;
          if (!maxConc[key] || resource.Factor > maxConc[key]) {
            maxConc[key] = resource.Factor;
          }
        });
      });
    }
    return maxConc;
  }, [planetData]);

  const ConcentrationBar = ({ concentration, materialId, resourceType }) => {
    const key = `${materialId}-${resourceType}`;
    const maxConcentration = maxConcentrations[key] || concentration;
    const percentage = isRelativeThreshold
      ? (concentration / maxConcentration) * 100
      : concentration * 100;
    const hue = (percentage / 100) * 120; 
    const backgroundColor = `hsl(${hue}, 100%, 50%)`;

    return (
      <div className="concentration-bar-container-sb" style={{ width: '100px', backgroundColor: '#ddd', height: '10px', marginLeft: '5px' }}>
        <div className="concentration-bar-sb" style={{ width: `${percentage}%`, backgroundColor, height: '100%' }} />
      </div>
    );
  };

  // --- Render Functions ---

  const renderStandardContent = () => {
    const planets = selectedSystem ? planetData[selectedSystem] : null;
    const sortedPlanets = planets ? [...planets].sort((a, b) => a.PlanetNaturalId.localeCompare(b.PlanetNaturalId)) : null;

    if (!selectedSystem) {
        return <div className="placeholder-text" style={{marginTop:'50px'}}>Select a system to view details.</div>;
    }

    return (
      <>
        <h2>{universeData[selectedSystem] ? universeData[selectedSystem][0].Name : 'No System Selected'}</h2>
        {sortedPlanets && sortedPlanets.map((planet) => {
          const activeCogc = getActiveCogc(planet);
          const shouldHighlightCard = isCardHighlighted(planet.PlanetNaturalId, planet);

          return (
            <div key={planet.PlanetNaturalId} className={`planet-info-sb ${shouldHighlightCard ? 'highlighted' : ''}`}>
              <h3>
                <PlanetTypeIcon isRocky={planet.Surface} cogcProgram={activeCogc} />
                <span style={{ marginLeft: '5px' }}>
                  {planet.PlanetName}{' '}
                  (<a href={`https://prunplanner.org/plan/${planet.PlanetNaturalId}`} className="planet-id-link" target="_blank" rel="noopener noreferrer">{planet.PlanetNaturalId}</a>)
                </span>
                {isConditionAbnormal('gravity', planet.Gravity) && (
                  <PlanetConditionIcon condition="gravity" value={planet.Gravity} ticker={getConditionTicker('gravity', planet.Gravity)} />
                )}
                {isConditionAbnormal('temperature', planet.Temperature) && (
                  <PlanetConditionIcon condition="temperature" value={planet.Temperature} ticker={getConditionTicker('temperature', planet.Temperature)} />
                )}
                {isConditionAbnormal('pressure', planet.Pressure) && (
                  <PlanetConditionIcon condition="pressure" value={planet.Pressure} ticker={getConditionTicker('pressure', planet.Pressure)} />
                )}
                {populationData && (
                  <WorkforceIcon planetId={planet.PlanetNaturalId} populationData={populationData} />
                )}
              </h3>
              <ul>
                {planet.Resources.map((resource, idx) => {
                  const key = `${resource.MaterialId}-${resource.ResourceType}`;
                  const shouldHighlightResource = isResourceHighlighted(resource.MaterialId, planet.PlanetNaturalId);
                  
                  return (
                    <li
                      key={idx}
                      className="resource-item-sb"
                      style={{
                        display: 'flex', alignItems: 'center', marginBottom: '5px',
                        fontWeight: shouldHighlightResource ? 'bold' : 'normal',
                        color: shouldHighlightResource ? '#4a90e2' : 'inherit',
                        backgroundColor: shouldHighlightResource ? 'rgba(74, 144, 226, 0.1)' : 'transparent',
                        padding: '2px 5px', borderRadius: '3px'
                      }}
                    >
                      <ResourceIcon type={resource.ResourceType} />
                      <span style={{ marginLeft: '5px', minWidth: '50px' }}>{materialsMap[resource.MaterialId]?.Ticker || 'Unknown'}</span>
                      <ConcentrationBar concentration={resource.Factor} materialId={resource.MaterialId} resourceType={resource.ResourceType} />
                      <span className="resource-percentage">
                        {isRelativeThreshold
                          ? ((resource.Factor / maxConcentrations[key]) * 100).toFixed(2)
                          : (resource.Factor * 100).toFixed(2)}%
                      </span>
                    </li>
                  );
                })}
              </ul>
              {isCompanySearch && shouldHighlightCard && <div className="company-base-indicator">Company Base</div>}
            </div>
          );
        })}
      </>
    );
  };

  const renderGatewayContent = () => (
    <div className="gateway-sidebar-content">
      <GatewayLegend />
      
      <div className="gateway-selection-info">
          {gatewayData.strategy === GATEWAY_STRATEGIES.SINGLE && (
              <>
                  <h4>Origin: {gatewayData.originA || 'None Selected'}</h4>
                  <div className="results-list">
                      <p className="placeholder-text">Select a system on the map to see nearby candidates.</p>
                  </div>
              </>
          )}
           {gatewayData.strategy === GATEWAY_STRATEGIES.DUAL && (
              <>
                  <h4>Origin A: {gatewayData.originA || 'None'}</h4>
                  <h4>Origin B: {gatewayData.originB || 'None'}</h4>
                  <div className="results-list">
                       <p className="placeholder-text">Select two systems to find midpoints.</p>
                  </div>
              </>
          )}
      </div>

      <div className="planned-gateways-section">
          <h4>Planned Gateways</h4>
          {gatewayData.plannedGateways.length === 0 ? (
              <p className="placeholder-text">No gateways planned yet.</p>
          ) : (
              <ul className="planned-list" style={{listStyle:'none', padding:0}}>
                  {gatewayData.plannedGateways.map(gw => (
                      <li key={gw.id} className="planned-gateway-item">
                          <span>{gw.source}  {gw.target}</span>
                          <span className="dist">({gw.distance}pc)</span>
                          <button className="delete-gw-btn" onClick={() => removePlannedGateway(gw.id)}>
                              <X size={14} />
                          </button>
                      </li>
                  ))}
              </ul>
          )}
      </div>
    </div>
  );

  return (
    <div className={`sidebar ${isCollapsed ? 'collapsed' : ''}`}>
      <button className="toggle-btn" onClick={toggleSidebar}>
        {isCollapsed ? <ChevronLeft /> : <ChevronRight />}
      </button>
      {!isCollapsed && (
        <div className="sidebar-content">
           {activeMode === MAP_MODES.STANDARD ? renderStandardContent() : renderGatewayContent()}
        </div>
      )}
    </div>
  );
};

export default Sidebar;

--- FILE: src/components/StandardControls.jsx ---

import React, { useState, useContext } from 'react';
import FilterCategories from './FilterCategories';
import MaterialSearchField from './MaterialSearchField';
import SearchField from './SearchField';
import { SearchContext } from '../contexts/SearchContext';

const StandardControls = () => {
  const [showFilters, setShowFilters] = useState(window.innerWidth > 768);
  const { clearSearch, toggleCompanySearch, isCompanySearch } = useContext(SearchContext);

  return (
    <div className="standard-controls">
      {/* Group 1: Filters (Originally header-center) */}
      <div className="std-ctrl-filters">
         <button
            className="filter-toggle"
            onClick={() => setShowFilters(!showFilters)}
          >
            {showFilters ? 'Hide Filters' : 'Show Filters'}
          </button>
          {showFilters && <FilterCategories />}
      </div>

      <div className="std-ctrl-right-group">
          {/* Group 2: Search Fields (Originally header-right) */}
          <div className="std-ctrl-search">
            <MaterialSearchField />
            <SearchField />
          </div>

          {/* Group 3: Action Buttons (Originally header-buttons) */}
          <div className="std-ctrl-buttons">
             <button className="clear-button" onClick={clearSearch}>Clear</button>
             <button
                onClick={toggleCompanySearch}
                className={`toggle-token company-search-toggle ${isCompanySearch ? 'active' : ''}`}
                data-tooltip={"Enter company code to search base data using FIO"}
             >
             Company
             </button>
          </div>
      </div>
    </div>
  );
};

export default StandardControls;

--- FILE: src/components/UniverseMap.css ---

/* UniverseMap.css */
#map-container {
  width: 100%;
  height: 100vh; /* Full viewport height */
  overflow: hidden;
  position: relative;
}

#map-container svg {
  width: 100%;
  height: 100%;
}

.info-panel {
  position: absolute;
  background-color: rgba(0, 0, 0, 0.8);
  color: #fff;
  padding: 15px;
  border-radius: 8px;
  pointer-events: none;
  z-index: 10;
  font-family: Arial, sans-serif;
  max-width: 400px;
  box-shadow: 0 0 10px rgba(255, 255, 255, 0.1);
}

.info-panel h3 {
  margin-top: 0;
  margin-bottom: 10px;
  font-size: 16px;
  border-bottom: 1px solid rgba(255, 255, 255, 0.3);
  padding-bottom: 5px;
}

.planet-list {
  list-style-type: none;
  padding-left: 0;
  margin-top: 5px;
}

.planet-list li {
  margin-bottom: 12px;
  font-size: 13px;
}

.planet-info {
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.planet-name-tier {
  display: flex;
  justify-content: space-between;
  align-items: center;
  width: 70%;
}

.planet-name {
  flex-grow: 1;
  margin-right: 10px;
}

.planet-tier {
  color: gold;
  white-space: nowrap;
  margin-right: 20px;
}

.facility-indicators {
  display: flex;
  align-items: center;
}

.facility-indicators span {
  margin-left: 1px;
}

.cogc-program {
  margin-bottom: 10px;
  padding-left: 10px;
}

.highlighted-planet {
  background-color: rgba(247, 166, 0, 0.2);
  border-radius: 4px;
}

.highlighted-planet .planet-name {
  font-weight: bold;
  color: #f7a600;
}

.matching-resources {
  margin-top: 5px;
  padding-top: 5px;
  border-top: 1px solid rgba(255, 255, 255, 0.2);
}

.resource-item {
  display: flex;
  align-items: center;
  margin-bottom: 5px;
  width: 100%; /* Ensure full width */
}

.resource-name {
  width: 40px;
  text-align: right;
  margin-right: 5px;
}

.concentration-bar-container {
  width: 100px;
  background-color: #ddd;
  height: 10px;
  margin: 0 5px;
}

.resource-percentage {
  width: 50px;
  text-align: right;
}

/* Media queries for smaller screen sizes */
@media (max-width: 820px) {
  .info-panel {
    max-width: 400px;
    padding: 10px;
  }

  .info-panel h3 {
    font-size: 14px;
    margin-bottom: 8px;
  }

  .planet-list li {
    font-size: 12px;
    margin-bottom: 8px;
  }

  .planet-name-tier {
    width: 100%;
    align-items: center;
  }

  .planet-name {
    margin-right: 5px;
    margin-bottom: 2px;
  }

  .planet-tier {
    margin-right: 5px;
    font-size: 10px;
  }

  .facility-indicators {
    margin-top: 4px;
  }

  .facility-indicators svg {
    width: 14px;
    height: 14px;
  }

  .cogc-program {
    font-size: 10px;
    margin-bottom: 6px;
    padding-left: 5px;
  }

  .resource-item {
    font-size: 10px;
  }

  .resource-name {
    width: 30px;
  }

  .concentration-bar-container {
    width: 70px;
    height: 8px;
  }

  .resource-percentage {
    width: 40px;
  }
}

--- FILE: src/components/UniverseMap.jsx ---

import React, { useEffect, useContext, useRef, useCallback } from 'react';
import DataPointOverlay from './DataPointOverlay';
import * as d3 from 'd3';
import { GraphContext } from '../contexts/GraphContext';
import { SelectionContext } from '../contexts/SelectionContext';
import { useCogcOverlay } from '../contexts/CogcOverlayContext';
import { addMouseEvents } from '../utils/svgUtils';
import { cogcPrograms } from '../constants/cogcPrograms';
import './UniverseMap.css';
import { SearchContext } from '../contexts/SearchContext';

// CX System IDs (Internal IDs)
const CX_SYSTEMS = [
  '8ecf9670ba070d78cfb5537e8d9f1b6c', // Antares
  '92029ff27c1abe932bd2c61ee4c492c7', // Benten
  'f2f57766ebaca9d69efae41ccf4d8853', // Hortus
  '49b6615d39ccba05752b3be77b2ebf36', // Moria
  'a4ba8b12739da65efc2b518703652ee1', // Arclight
  'afda9bea7f948f4a066a8882cdfa9055'  // Hubur
];

const UniverseMap = React.memo(() => {
  const { graph, planetData, materials } = useContext(GraphContext);
  const { highlightSelectedSystem } = useContext(SelectionContext);
  const { overlayProgram } = useCogcOverlay();
  const { searchResults, isRelativeThreshold } = useContext(SearchContext);
  const svgRef = useRef(null);
  const graphRef = useRef(null);

  // Derive the actual program value (e.g., ADVERTISING_METALLURGY) from the display name
  const selectedProgramValue = cogcPrograms.find(program => program.display === overlayProgram)?.value;

  // Handle system click
  const handleSystemClick = useCallback((systemId) => {
    if (systemId === 'rect1') {
      return;
    }
    highlightSelectedSystem(systemId);
  }, [highlightSelectedSystem]);

  // Attach click events
  const attachClickEvents = useCallback((g) => {
    g.selectAll('rect').on('click', function() {
      const systemId = d3.select(this).attr('id').replace('#', '');
      handleSystemClick(systemId);
    });
  }, [handleSystemClick]);

  // Initialize D3 graph
  useEffect(() => {
    if (!graph || !graph.edges) return;

    d3.xml('PrUn_universe_map_normalized.svg').then(data => {
      const svgNode = data.documentElement;
      const container = document.getElementById('map-container');

      // Clear any existing SVG to prevent duplicates
      while (container.firstChild) {
        container.removeChild(container.firstChild);
      }

      // Append the SVG node to the container
      container.appendChild(svgNode);

      // Select the SVG element and create a group element
      const svg = d3.select(svgNode);
      const g = svg.append('g');

      // Move all children of the SVG to the group
      while (svgNode.firstChild && svgNode.firstChild !== g.node()) {
        g.node().appendChild(svgNode.firstChild);
      }

      // Apply shapes to CX Systems ---
      g.selectAll('rect').each(function() {
        const systemId = d3.select(this).attr('id');
        if (CX_SYSTEMS.includes(systemId)) {
          d3.select(this).attr('rx', '2').attr('ry', '2');
        }
      });

      graphRef.current = { svg, g };

      const zoom = d3.zoom()
        .scaleExtent([1, 20])
        .on('zoom', (event) => {
          g.attr('transform', event.transform);
        });

      svg.call(zoom);

      // Pass selectedProgramValue to addMouseEvents
      addMouseEvents(g, searchResults, materials, undefined, selectedProgramValue);

      // Store references for later use
      svgRef.current = svgNode;
      graphRef.current = { svg, g };

      // Attach click events here, after the SVG is fully initialized
      attachClickEvents(g);
    });

    // Cleanup function
    return () => {
      if (svgRef.current) {
        const container = document.getElementById('map-container');
        if (container && container.contains(svgRef.current)) {
          container.removeChild(svgRef.current);
        }
      }
    };
  // eslint-disable-next-line
  }, [graph]);

  // Update mouse events when search results OR cogc selection changes
  useEffect(() => {
    if (graphRef.current) {
      addMouseEvents(
          graphRef.current.g, 
          searchResults, 
          materials, 
          isRelativeThreshold, 
          selectedProgramValue
      );
    }
  }, [searchResults, materials, isRelativeThreshold, selectedProgramValue]);

  // Apply Cogc overlay
  const applyCogcOverlay = useCallback(() => {
    if (!graphRef.current || !overlayProgram) return;

    const { g } = graphRef.current;

    g.selectAll('.cogc-overlay-rect').remove();

    g.selectAll('rect').each(function() {
      const rect = d3.select(this);
      const systemId = d3.select(this).attr('id');
      const planets = planetData[systemId];

      if (planets && planets.some(planet => {
        if (!planet.COGCPrograms || planet.COGCPrograms.length === 0) return false;
        const sortedPrograms = planet.COGCPrograms.sort((a, b) => b.StartEpochMs - a.StartEpochMs);
        const relevantProgram = sortedPrograms[1] || sortedPrograms[0];
        return relevantProgram && relevantProgram.ProgramType === selectedProgramValue;
      })) {
        rect.classed('cogc-overlay', true);
        const x = parseFloat(rect.attr('x'));
        const y = parseFloat(rect.attr('y'));
        const width = parseFloat(rect.attr('width'));
        const height = parseFloat(rect.attr('height'));
        const scaleUp = 4;
        
        // Apply correct shape to overlay ---
        const isCX = CX_SYSTEMS.includes(systemId);
        const borderRadius = isCX ? '4' : '50%';

        // Create a new overlay rect
        const overlayRect = g.append('rect')
          .attr('class', 'cogc-overlay-rect')
          .attr('x', x - scaleUp/2)
          .attr('y', y - scaleUp/2)
          .attr('width', width + scaleUp)
          .attr('height', height + scaleUp)
          .attr('fill', 'none')
          .attr('stroke', '#56c7f7')
          .attr('stroke-width', '3px')
          .attr('rx', borderRadius)
          .attr('ry', borderRadius);
        rect.property('cogcOverlayRect', overlayRect);
      } else {
        rect.classed('cogc-overlay', false);
        rect.property('cogcOverlayRect', null);
      }
    });
  }, [overlayProgram, planetData, selectedProgramValue]);

  // Effect to apply Cogc overlay when overlayProgram changes
  useEffect(() => {
    applyCogcOverlay();
  }, [applyCogcOverlay]);

  // Update click events when handleSystemClick changes
  useEffect(() => {
    if (graphRef.current) {
      attachClickEvents(graphRef.current.g);
    }
  }, [attachClickEvents]);

  return (
    <div id="map-container">
      <DataPointOverlay mapRef={graphRef} />
    </div>
  );
});

export default UniverseMap;

--- FILE: src/config/config.js ---

// Color palette and configuration constants
export const colors = {
  searchSystemFill: '#f7a600',
  searchSystemStroke: '#000000',
  searchSystemStrokeWidth: '1px',
  searchSystemFillLowLiquid: '#fcb6b6',
  searchSystemFillLiquid: '#ff0000',
  searchSystemFillLowGaseous: '#a2defc',
  searchSystemFillGaseous: '#009eed',
  searchSystemFillLowMineral: '#cefab9',
  searchSystemFillMineral: '#3fbf00',
  systemFill: '#f7a600',
  systemStroke: '#000000',
  pathStroke: '#f7a600',
  pathStrokeWidth: '2px',
  resetSystemFill: '#cccccc',
  resetSystemStroke: '#000000',
  resetSystemFillOpacity: 0.8,
  resetSystemStrokeWidth: '1px',
  resetPathStroke: '#6e7980',
  resetPathStrokeWidth: '1px',
  
  // Tol Palette (Vibrant/Muted mix for distinctness)
  tol: {
    navy: '#332288',
    green: '#117733',
    teal: '#44AA99',
    lightBlue: '#88CCEE',
    sand: '#DDCC77',
    rose: '#CC6677',
    purple: '#AA4499',
    wine: '#882255'
  },
  
  // Gateway Distance Mapping
  gateway: {
    under10: '#117733', // Green
    under15: '#44AA99', // Teal
    under20: '#DDCC77', // Sand
    under25: '#CC6677', // Rose
    over25: '#882255'   // Wine
  }
};

--- FILE: src/hooks/useFetchGraphData.js ---

import { useState, useEffect } from 'react';

export const useFetchGraphData = () => {
  const [graphData, setGraphData] = useState(null);

  useEffect(() => {
    console.log('useFetchGraphData hook executed');
    fetch('graph_data.json')
      .then(response => response.json())
      .then(data => {
        console.log('Fetched Graph Data:', data);
        setGraphData(data);
      })
      .catch(error => {
        console.error('Error fetching graph data:', error);
      });
  }, []);

  return graphData;
};

--- FILE: src/hooks/useGraphState.js ---

import { useState, useCallback } from 'react';
import fetchGraphData from './useFetchGraphData';

const useGraphState = () => {
  const [graph, setGraph] = useState({ nodes: {}, edges: [] });

  const fetchGraphDataCallback = useCallback(async () => {
    const data = await useFetchGraphData();
    setGraph(data);
  }, []);

  return {
    graph,
    fetchGraphData: fetchGraphDataCallback,
  };
};

export default useGraphState;


--- FILE: src/constants/cogcPrograms.js ---

export const cogcPrograms = [
  { value: "ALL", display: "All Programs" },
  { value: null, display: "No Program" },
  { value: "ADVERTISING_RESOURCE_EXTRACTION", display: "Resource Ext." },
  { value: "ADVERTISING_CHEMISTRY", display: "Chemistry" },
  { value: "ADVERTISING_METALLURGY", display: "Metallurgy" },
  { value: "ADVERTISING_MANUFACTURING", display: "Manufacturing" },
  { value: "ADVERTISING_AGRICULTURE", display: "Agriculture" },
  { value: "ADVERTISING_FOOD_INDUSTRIES", display: "Food Industries" },
  { value: "ADVERTISING_CONSTRUCTION", display: "Construction" },
  { value: "ADVERTISING_FUEL_REFINING", display: "Fuel Refining" },
  { value: "ADVERTISING_ELECTRONICS", display: "Electronics" }
];

--- FILE: public/index.html ---

<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <link rel="icon" href="%PUBLIC_URL%/icons/icon-72x72.png" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="theme-color" content="#000000" />
    <meta
      name="description"
      content="Taiyi's Prosperous Universe Map - An interactive map for the Prosperous Universe game"
    />
    <link rel="apple-touch-icon" href="%PUBLIC_URL%/icons/icon-192x192.png" />
    <!--
      manifest.json provides metadata used when your web app is installed on a
      user's mobile device or desktop. See https://developers.google.com/web/fundamentals/web-app-manifest/
    -->
    <link rel="manifest" href="%PUBLIC_URL%/manifest.json" />
    <!--
      Notice the use of %PUBLIC_URL% in the tags above.
      It will be replaced with the URL of the `public` folder during the build.
      Only files inside the `public` folder can be referenced from the HTML.

      Unlike "/favicon.ico" or "favicon.ico", "%PUBLIC_URL%/favicon.ico" will
      work correctly both with client-side routing and a non-root public URL.
      Learn how to configure a non-root public URL by running `npm run build`.
    -->
    <title>Taiyi's Prosperous Universe Map</title>
  </head>
  <body>
    <noscript>You need to enable JavaScript to run this app.</noscript>
    <div id="root"></div>
    <!--
      This HTML file is a template.
      If you open it directly in the browser, you will see an empty page.

      You can add webfonts, meta tags, or analytics to this file.
      The build step will place the bundled scripts into the <body> tag.

      To begin the development, run `npm start` or `yarn start`.
      To create a production bundle, use `npm run build` or `yarn build`.
    -->
  </body>
</html>
