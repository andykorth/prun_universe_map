

--- FILE: README.md ---

# Taiyi's Prosperous Universe Map
An interactive, data-rich visualization of the Prosperous Universe game world. 
This project provides a user-friendly interface for exploring star systems, planets, and their resources, 
with features including:

Interactive SVG-based map of the game universe
Detailed information panels for each star system and planet
Pathfinding functionality to plot routes between systems
Visual indicators for planet tiers and available facilities
Integration with game data for up-to-date information on resources and COGC programs
React-based UI with D3.js for smooth interactions and animations

Perfect for players looking to plan their interstellar trade routes or for those curious about the vast 
Prosperous Universe game world. Contributions welcome!

### Tech Stack:

* React
* D3.js
* SVG
* Tailwind CSS

### Updating the PRUN data:

* Replace `public/prun_universe_data.json` with the contents from the FIO endpoint: https://rest.fnar.net/systemstars
* Replace `public/planet_data.json` with the contents of: https://rest.fnar.net/planet/allplanets/full
* Run the python script 

### Getting Started with Create React App

This project was bootstrapped with [Create React App](https://github.com/facebook/create-react-app).

### Available Scripts

In the project directory, you can run:

#### `npm start`

Runs the app in the development mode.\
Open [http://localhost:3000](http://localhost:3000) to view it in your browser.

The page will reload when you make changes.\
You may also see any lint errors in the console.

#### `npm test`

Launches the test runner in the interactive watch mode.\
See the section about [running tests](https://facebook.github.io/create-react-app/docs/running-tests) for more information.

#### `npm run build`

Builds the app for production to the `build` folder.\
It correctly bundles React in production mode and optimizes the build for the best performance.

The build is minified and the filenames include the hashes.\
Your app is ready to be deployed!

See the section about [deployment](https://facebook.github.io/create-react-app/docs/deployment) for more information.

#### `npm run eject`

**Note: this is a one-way operation. Once you `eject`, you can't go back!**

If you aren't satisfied with the build tool and configuration choices, you can `eject` at any time. This command will remove the single build dependency from your project.

Instead, it will copy all the configuration files and the transitive dependencies (webpack, Babel, ESLint, etc) right into your project so you have full control over them. All of the commands except `eject` will still work, but they will point to the copied scripts so you can tweak them. At this point you're on your own.

You don't have to ever use `eject`. The curated feature set is suitable for small and middle deployments, and you shouldn't feel obligated to use this feature. However we understand that this tool wouldn't be useful if you couldn't customize it when you are ready for it.

### Learn More

You can learn more in the [Create React App documentation](https://facebook.github.io/create-react-app/docs/getting-started).

To learn React, check out the [React documentation](https://reactjs.org/).

#### Code Splitting

This section has moved here: [https://facebook.github.io/create-react-app/docs/code-splitting](https://facebook.github.io/create-react-app/docs/code-splitting)

#### Analyzing the Bundle Size

This section has moved here: [https://facebook.github.io/create-react-app/docs/analyzing-the-bundle-size](https://facebook.github.io/create-react-app/docs/analyzing-the-bundle-size)

#### Making a Progressive Web App

This section has moved here: [https://facebook.github.io/create-react-app/docs/making-a-progressive-web-app](https://facebook.github.io/create-react-app/docs/making-a-progressive-web-app)

#### Advanced Configuration

This section has moved here: [https://facebook.github.io/create-react-app/docs/advanced-configuration](https://facebook.github.io/create-react-app/docs/advanced-configuration)

#### Deployment

This section has moved here: [https://facebook.github.io/create-react-app/docs/deployment](https://facebook.github.io/create-react-app/docs/deployment)

#### `npm run build` fails to minify

This section has moved here: [https://facebook.github.io/create-react-app/docs/troubleshooting#npm-run-build-fails-to-minify](https://facebook.github.io/create-react-app/docs/troubleshooting#npm-run-build-fails-to-minify)


--- FILE: src/App.css ---

/* App.css */

body {
  background-color: #222222;
  margin: 0;
  font-family: Arial, sans-serif;
}

.App {
  display: flex;
  flex-direction: column;
  height: 100vh;
  color: white;
}

.App-header {
  display: flex;
  flex-wrap: wrap;
  justify-content: space-between;
  align-items: center;
  padding: 10px;
  background-color: #222222;
}

.header-right {
    flex-direction: column;
}

.header-left, .header-center, .header-right {
  display: flex;
  align-items: center;
  flex: 1 1 auto;
  margin-bottom: 2px;
}

.header-center {
  justify-content: start;
}

.header-right {
  align-items: end;
  justify-content: center;
  flex-wrap: wrap;
}

.header-info {
  display: flex;
  flex: 0 1 auto;
  margin-bottom: 2px;
  flex-flow: row wrap;
  align-items: start;
  justify-content: center;
}

.header-buttons {
  display: flex;
  flex: 0 1 auto;
  margin-bottom: 2px;
  flex-flow: row wrap;
  flex-direction: column;
  align-items: center;
  justify-content: center;
}

.material-search-field,
.search-field,
.clear-button,
.pathfinding-toggle-container {
  margin: 5px;
}

.toggle-stack-container {
  display: flex;
  flex-direction: column;
  gap: 0px;
  position: relative;
}

.App-logo {
  width: 50px;
  height: 50px;
  margin-right: 10px;
  border-radius: 50%;
}

.App-header h1 {
  font-size: 18px;
  margin: 0;
  white-space: nowrap;
}

.filter-toggle {
  background-color: #f7a600;
  border: none;
  color: white;
  padding: 5px 10px;
  cursor: pointer;
  border-radius: 4px;
  margin-right: 10px;
}

.filter-categories {
  display: flex;
  justify-content: space-around;
  flex-wrap: wrap;
}

.filter-category {
  margin: 0 10px;
}

.filter-category h4 {
  margin: 0 0 5px 0;
  color: #f7a600;
  font-size: 14px;
}

.checkbox-group {
  display: flex;
  flex-direction: column;
}

.checkbox-label {
  position: relative;
  display: flex;
  align-items: center;
  margin-bottom: 3px;
  color: #fff;
  font-size: 12px;
}

.checkbox-label input {
  margin-right: 5px;
}

.material-search-field input,
.search-field input {
  padding: 5px 10px;
  border: 1px solid #ccc;
  border-radius: 4px 0 0 4px;
  background-color: #333;
  color: #fff;
  margin-left: 5px;
}

.search-controls button {
  padding: 5px 10px;
  background-color: #f7a600;
  border: none;
  color: white;
  cursor: pointer;
  border-radius: 4px;
  margin-right: 5px;
}

.main-content {
  display: flex;
  flex: 1;
  overflow: hidden;
  position: relative;
}

#map-container {
  flex: 1;
  overflow: hidden;
  position: relative;
}

.sidebar {
  width: max(20%, 250px);
  background-color: #333333;
  transition: width 0.3s ease;
  position: relative;
  z-index: 10;
}

.sidebar.collapsed {
  width: 20px;
}

.toggle-btn {
  position: absolute;
  top: 10px;
  left: -30px;
  background-color: #444444;
  border: none;
  color: white;
  padding: 5px;
  cursor: pointer;
}

.sidebar-content {
  padding: 20px;
  padding-bottom: 20px;
  overflow-y: auto;
  height: 100%;
  box-sizing: border-box;
}

.sidebar-content svg {
  display: inline-block;
  vertical-align: middle;
  width: 18px;
  height: 18px;
}

.planet-info-sb {
  margin-bottom: 20px;
}

.sidebar .planet-id-link {
  color: #FFC107;            /* amber/gold */
  text-decoration: none;
}

.sidebar .planet-id-link:visited {
  color: #FFB300;
}

.sidebar .planet-id-link:hover {
  color: #FFECB3;            /* pale gold */
  text-decoration: underline;
}

.sidebar .planet-id-link:focus,
.sidebar .planet-id-link:active {
  outline: 2px solid #FFECB3;
  outline-offset: 2px;
}

.resource-item-sb {
  display: flex;
  align-items: center;
  margin-bottom: 5px;
}

.concentration-bar-container-sb {
  width: 100px;
  background-color: #ddd;
  height: 10px;
  margin-left: 5px;
}

.concentration-bar-sb {
  height: 100%;
  transition: width 0.3s ease;
}

.resource-percentage {
  display: inline-block;
  min-width: 50px;
  text-align: right;
  margin-left: 5px;
}

.pathfinding-toggle {
  display: flex;
  align-items: center;
  cursor: pointer;
  font-size: 12px;
}

.pathfinding-toggle .toggle-token {
  margin: 0px;
  margin-right: 8px;
}

.pathfinding-toggle .toggle-token::before {
  content: "Pathfinding";
}

.meteor-density-toggle .toggle-token::before {
  content: "Data Overlay";
}

.info-tooltip-container {
  margin-top: 5px;
  margin-left: 5px;
  margin-right: 5px;
}

.tooltip {
  font-size: 12px;
  line-height: 1.4;
}

.tooltip h4 {
  font-size: 14px;
  margin-bottom: 8px;
}

.tooltip ul {
  margin: 0;
  padding: 0;
  list-style-type: none;
}

.tooltip li {
  margin-bottom: 4px;
}

.search-highlight {
  transform-box: fill-box;
  transform-origin: center;
}

search-container {
  display: flex;
  align-items: center;
  margin-right: 10px;
}

.search-button {
  background-color: #f7a600;
  border: none;
  color: white;
  padding: 6px 5px;
  cursor: pointer;
  border-radius: 0 4px 4px 0;
}

.search-notification {
  position: fixed;
  top: 85px;
  left: 50%;
  transform: translateX(-50%);
  background-color: rgba(0, 0, 0, 0.8);
  color: white;
  padding: 10px 20px;
  border-radius: 5px;
  z-index: 1000;
  animation: fadeInOut 3s ease-in-out;
}

@keyframes fadeInOut {
  0%, 100% { opacity: 0; }
  10%, 90% { opacity: 1; }
}

.clear-button {
  background-color: #6c757d;
  border: none;
  color: white;
  padding: 6px 10px;
  cursor: pointer;
  border-radius: 4px;
  margin-right: 10px;
  margin-left: 5px;
}

.checkbox-label:hover::after {
  content: attr(data-tooltip);
  position: absolute;
  background-color: #333;
  color: #fff;
  padding: 5px;
  border-radius: 4px;
  font-size: 12px;
  white-space: nowrap;
  z-index: 1000;
  bottom: 0;
  left: -15px;
  transform: translateX(-50%);
}

.planet-condition-icon {
  position: relative;
  display: inline-block;
  margin-left: 5px;
  cursor: help;
}

.planet-condition-icon .tooltip {
  position: absolute;
  top: 100%;
  left: 50%;
  transform: translateX(-50%);
  background: #333;
  color: #fff;
  padding: 5px;
  border-radius: 3px;
  font-size: 12px;
  white-space: nowrap;
  z-index: 1000;
  pointer-events: none;
}

.company-base-indicator {
  background-color: #f7a600;
  color: white;
  padding: 2px 5px;
  border-radius: 3px;
  font-size: 12px;
  margin-top: 5px;
  display: inline-block;
}

.planet-info-sb.highlighted {
  border-left: 3px solid #f7a600;
  padding-left: 5px;
}

.company-search-toggle {
  margin-top: 5px;
  margin-bottom: 5px;
}

/* Adjusted css for small screen sizes */

@media (max-width: 820px) {
  .App-header {
    flex-wrap: wrap;
    justify-content: center;
    padding: 5px;
  }

  .header-left {
    display: none; /* This hides the logo and title */
  }

  .header-right, .header-info .header-buttons {
    flex-direction: column;
  }

  .header-left, .header-center, .header-right, .header-info .header-buttons {
    flex: 0 1 auto;
  }

  .filter-toggle {
    padding: 3px 6px;
    font-size: 12px;
  }

  .filter-categories {
    flex-direction: row;
    flex-wrap: wrap;
    justify-content: center;
  }

  .filter-category {
    margin: 3px;
  }

  .filter-category h4 {
    font-size: 11px;
  }

  .checkbox-label {
    font-size: 10px;
  }

  .material-search-field input,
  .search-field input {
    padding: 3px 5px;
    font-size: 12px;
  }

  .search-button {
    padding: 4px 5px;
    font-size: 12px;
  }

  .clear-button {
    padding: 4px 5px;
    font-size: 12px;
    margin-right: 5px;
    margin-bottom: 10px;
  }

  .info-tooltip-container {
    margin-top: 0px;
    margin-left: 5px;
  }

  .pathfinding-toggle .toggle-token::before {
    content: "Path";
  }

  .meteor-density-toggle .toggle-token::before {
    content: "Data";
  }

  .sidebar {
    width: max(20%, 250px);
  }

  .sidebar.collapsed {
    width: 10px;
  }

  .sidebar-content {
    padding: 10px;
    padding-bottom: 5px;
  }

  .sidebar-content h3 {
    font-size: 16px;
  }

  .sidebar-content h2 {
    font-size: 22px;
  }

  .sidebar-content svg {
    width: 18px;
    height: 18px;
  }

  .resource-item-sb {
    font-size: 14px;
  }
}

--- FILE: src/App.js ---

import React, { useState } from 'react';
import UniverseMap from './components/UniverseMap';
import Sidebar from './components/Sidebar';
import PathfindingToggle from './components/PathfindingToggle';
import MeteorDensityToggle from './components/MeteorDensityToggle';
import SearchField from './components/SearchField';
import MaterialSearchField from './components/MaterialSearchField';
import FilterCategories from './components/FilterCategories';
import InfoTooltip from './components/InfoTooltip';
import { GraphProvider } from './contexts/GraphContext';
import { SelectionProvider } from './contexts/SelectionContext';
import { SearchProvider, SearchContext } from './contexts/SearchContext';
import { CogcOverlayProvider } from './contexts/CogcOverlayContext';
import { DataPointProvider } from './contexts/DataPointContext';
import './App.css';
import './components/FilterCategories.css';
import logo from './logo.png';

const App = () => {
  const [showFilters, setShowFilters] = useState(window.innerWidth > 768);

  return (
    <GraphProvider>
      <SelectionProvider>
        <SearchProvider>
          <CogcOverlayProvider>
            <DataPointProvider>
              <AppContent
                showFilters={showFilters}
                setShowFilters={setShowFilters}
              />
            </DataPointProvider>
          </CogcOverlayProvider>
        </SearchProvider>
      </SelectionProvider>
    </GraphProvider>
  );
};

const AppContent = ({ showFilters, setShowFilters }) => {
  const { clearSearch, isCompanySearch, toggleCompanySearch } = React.useContext(SearchContext);

  return (
    <div className="App">
      <header className="App-header">
        <div className="header-left">
          <img src={logo} alt="Logo" className="App-logo" />
          <h1>Taiyi's Prosperous Universe Map</h1>
        </div>
        <div className="header-center">
          <button
            className="filter-toggle"
            onClick={() => setShowFilters(!showFilters)}
          >
            {showFilters ? 'Hide Filters' : 'Show Filters'}
          </button>
          {showFilters && <FilterCategories />}
        </div>
        <div className="header-right">
          <MaterialSearchField />
          <SearchField />
        </div>
        <div className="header-buttons">
          <button className="clear-button" onClick={clearSearch}>Clear</button>
          <button
            onClick={toggleCompanySearch}
            className={`toggle-token company-search-toggle ${isCompanySearch ? 'active' : ''}`}
            data-tooltip={"Enter company code to search base data using FIO"}
          >
          Company
          </button>
        </div>
        <div className="header-info">
          <InfoTooltip />
            <div className="toggle-stack-container">
            <div className="pathfinding-toggle-container">
              <PathfindingToggle />
            </div>
            <div className="pathfinding-toggle-container">
              <MeteorDensityToggle />
            </div>
          </div>
        </div>
        </header>
      <div className="main-content">
        <UniverseMap />
        <Sidebar />
      </div>
    </div>
  );
};

export default App;

--- FILE: src/App.test.js ---

import { render, screen } from '@testing-library/react';
import App from './App';

test('renders learn react link', () => {
  render(<App />);
  const linkElement = screen.getByText(/learn react/i);
  expect(linkElement).toBeInTheDocument();
});


--- FILE: src/index.css ---

body {
  margin: 0;
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen',
    'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue',
    sans-serif;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

code {
  font-family: source-code-pro, Menlo, Monaco, Consolas, 'Courier New',
    monospace;
}


--- FILE: src/index.js ---

import React from 'react';
import ReactDOM from 'react-dom/client';
import './index.css';
import App from './App';
import reportWebVitals from './reportWebVitals';

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);

// If you want to start measuring performance in your app, pass a function
// to log results (for example: reportWebVitals(console.log))
// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals
reportWebVitals();


--- FILE: src/reportWebVitals.js ---

const reportWebVitals = onPerfEntry => {
  if (onPerfEntry && onPerfEntry instanceof Function) {
    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {
      getCLS(onPerfEntry);
      getFID(onPerfEntry);
      getFCP(onPerfEntry);
      getLCP(onPerfEntry);
      getTTFB(onPerfEntry);
    });
  }
};

export default reportWebVitals;


--- FILE: src/setupTests.js ---

// jest-dom adds custom jest matchers for asserting on DOM nodes.
// allows you to do things like:
// expect(element).toHaveTextContent(/react/i)
// learn more: https://github.com/testing-library/jest-dom
import '@testing-library/jest-dom';


--- FILE: src/contexts/CogcOverlayContext.js ---

import React, { createContext, useState, useContext } from 'react';

const CogcOverlayContext = createContext();

export const CogcOverlayProvider = ({ children }) => {
  const [overlayProgram, setOverlayProgram] = useState(null);

  return (
    <CogcOverlayContext.Provider value={{ overlayProgram, setOverlayProgram }}>
      {children}
    </CogcOverlayContext.Provider>
  );
};

export const useCogcOverlay = () => useContext(CogcOverlayContext);

--- FILE: src/contexts/DataPointContext.js ---

import React, { createContext, useState, useContext, useCallback, useMemo, useEffect } from 'react';

// Create the context
export const DataPointContext = createContext();

export const DataPointProvider = ({ children }) => {
  // State for system meteorite density data
  const [meteorDensityData, setMeteorDensityData] = useState({});
  const [luminosityData, setLuminosityData] = useState({});
  const [systemNames, setSystemNames] = useState({});
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState(null);

  // Visibility toggle for the overlay
  const [isOverlayVisible, setIsOverlayVisible] = useState(false);

  // Scale setting (absolute vs relative)
  const [useRelativeScale, setUseRelativeScale] = useState(false);

  // Fetch system stars data
  useEffect(() => {
    const fetchMeteorData = async () => {
      try {
        setIsLoading(true);
        const response = await fetch('systemstars.json');
        if (!response.ok) {
          throw new Error('Failed to fetch system stars data');
        }
        const data = await response.json();

        // Transform data into maps for density and system names
        const densityMap = {};
        const luminosityMap = {};
        const systemNameMap = {};
        data.forEach(system => {
          densityMap[system.SystemId] = system.MeteoroidDensity;
          luminosityMap[system.SystemId] = system.Luminosity;
          systemNameMap[system.SystemId] = system.Name;
        });

        setMeteorDensityData(densityMap);
        setLuminosityData(luminosityMap);
        setSystemNames(systemNameMap);
        setError(null);
      } catch (err) {
        console.error('Error fetching meteor density data:', err);
        setError(err.message);
      } finally {
        setIsLoading(false);
      }
    };

    fetchMeteorData();
  }, []);

  // Get meteorite density for a specific system
  const getSystemMeteorDensity = useCallback((systemId) => {
    return meteorDensityData[systemId] || 0;
  }, [meteorDensityData]);

  const getSystemLuminosity = useCallback((systemId) => {
    return luminosityData[systemId] || 0;
  }, [luminosityData]);

  // Toggle overlay visibility
  const toggleOverlayVisibility = useCallback(() => {
    setIsOverlayVisible(prev => !prev);
  }, []);

  // Toggle scale type
  const toggleScaleType = useCallback(() => {
    setUseRelativeScale(prev => !prev);
  }, []);

  // Get maximum density and luminosity value for relative scaling
  const maxValues = useMemo(() => ({
    density: Math.max(0, ...Object.values(meteorDensityData)),
    luminosity: Math.max(0, ...Object.values(luminosityData))
  }), [meteorDensityData, luminosityData]);

  // Calculate normalized density based on scale type
  const getNormalizedValue = useCallback((value, type) => {
    if (!useRelativeScale) return value;
    const maxValue = maxValues[type];
    return maxValue === 0 ? 0 : value / maxValue;
  }, [useRelativeScale, maxValues]);

  const contextValue = {
    meteorDensityData,
    luminosityData,
    systemNames,
    isOverlayVisible,
    useRelativeScale,
    isLoading,
    error,
    getSystemMeteorDensity,
    getSystemLuminosity,
    toggleOverlayVisibility,
    toggleScaleType,
    getNormalizedValue,
    maxValues
  };

  return (
<DataPointContext.Provider value={contextValue}>
{children}
</DataPointContext.Provider>
);
};

// Custom hook for using the data point context
export const useDataPoints = () => {
const context = useContext(DataPointContext);
if (!context) {
throw new Error('useDataPoints must be used within a DataPointProvider');
}
return context;
};

--- FILE: src/contexts/GraphContext.js ---

import React, { createContext, useState, useEffect, useCallback } from 'react';
import { findShortestPath as findShortestPathUtil, highlightPath} from '../utils/graphUtils';

export const GraphContext = createContext();

export const GraphProvider = ({ children }) => {
  const [graph, setGraph] = useState({ nodes: {}, edges: [] });
  const [materials, setMaterials] = useState({});
  const [selectedSystems, setSelectedSystems] = useState([]);
  const [planetData, setPlanetData] = useState({});
  const [universeData, setUniverseData] = useState({});

  useEffect(() => {
    console.log('Fetching graph data');
    fetch('graph_data.json')
      .then(response => response.json())
      .then(data => {
        setGraph(data);
      })
      .catch(error => {
        console.error('Error fetching graph data:', error);
      });

    fetch('material_data.json')
      .then(response => response.json())
      .then(data => {
        setMaterials(data);
      })
      .catch(error => {
        console.error('Error fetching material data:', error);
      });

    fetch('prun_universe_data.json')
      .then(response => response.json())
      .then(data => {
        // Group planets by SystemId
        const groupedUniverseData = data.reduce((acc, system) => {
          if (!acc[system.SystemId]) {
            acc[system.SystemId] = [];
          }
          acc[system.SystemId].push(system);
          return acc;
        }, {});
        setUniverseData(groupedUniverseData);
      })
      .catch(error => {
        console.error('Error fetching universe data:', error);
      });

    // Fetch planet data
    fetch('planet_data.json')
      .then(response => response.json())
      .then(data => {
        // Group planets by SystemId
        const groupedPlanetData = data.reduce((acc, planet) => {
          if (!acc[planet.SystemId]) {
            acc[planet.SystemId] = [];
          }
          acc[planet.SystemId].push(planet);
          return acc;
        }, {});
        setPlanetData(groupedPlanetData);
      })
      .catch(error => {
        console.error('Error fetching planet data:', error);
      });
  }, []);

  const findShortestPath = useCallback((system1, system2) => {
    findShortestPathUtil(graph, system1, system2, highlightPath);
  }, [graph]);


  return (
    <GraphContext.Provider
      value={{
        graph,
        setGraph,
        materials,
        setMaterials,
        selectedSystems,
        setSelectedSystems,
        findShortestPath,
        planetData,
        universeData
      }}
    >
      {children}
    </GraphContext.Provider>
  );
};

--- FILE: src/contexts/SearchContext.js ---

import React, { createContext, useState, useCallback, useContext } from 'react';
import { GraphContext } from './GraphContext';
import { highlightSearchResults, clearHighlights } from '../utils/searchUtils';


export const SearchContext = createContext();

const sanitizeInput = (input) => {
  // Remove any HTML tags
  let sanitized = input.replace(/<[^>]*>/g, '');
  // Remove special characters except spaces, hyphens, and parentheses
  sanitized = sanitized.replace(/[^a-zA-Z0-9\s\-()]/g, '');
  // Trim whitespace from the beginning and end
  sanitized = sanitized.trim();
  // Limit the length of the input
  const maxLength = 500;
  sanitized = sanitized.slice(0, maxLength);

  return sanitized;
};

// Helper function to split camelCase into separate words.
const splitCamelCase = (str) => {
  return str.replace(/([a-z])([A-Z])/g, '$1 $2').toLowerCase();
};

export const SearchProvider = ({ children }) => {
  const [searchResults, setSearchResults] = useState([]);
  const { universeData, planetData, materials } = useContext(GraphContext);
  const [searchMaterial, setSearchMaterial] = useState([]);
  const [searchMaterialConcentrationLiquid, setSearchMaterialConcentrationLiquid] = useState([]);
  const [searchMaterialConcentrationGaseous, setSearchMaterialConcentrationGaseous] = useState([]);
  const [searchMaterialConcentrationMineral, setSearchMaterialConcentrationMineral] = useState([]);
  const [filters, setFilters] = useState({
    planetType: ['Rocky', 'Gaseous'],
    gravity: ['Low', 'High'],
    temperature: ['Low', 'High'],
    pressure: ['Low', 'High'],
    cogcProgram: []
  });
  const [systemSearchTerm, setSystemSearchTerm] = useState('');
  const [materialSearchTerm, setMaterialSearchTerm] = useState('');
  const [resourceThreshold, setResourceThreshold] = useState(0);
  const [isRelativeThreshold, setIsRelativeThreshold] = useState(false);
  const [resourceTypeFilter, setResourceTypeFilter] = useState('ALL');
  const [companySearchTerm, setCompanySearchTerm] = useState('');
  const [isCompanySearch, setIsCompanySearch] = useState(false);


  const handleSystemSearch = useCallback((searchTerm) => {
    const sanitizedSearchTerm = sanitizeInput(searchTerm);
    const results = [];
    const terms = sanitizedSearchTerm.split(/\s+/)
        .filter(term => term.length >= 2); // Only keep terms with 1 or more characters

    terms.forEach(term => {
      const lowerTerm = term.toLowerCase();

      // Search in systems
      Object.entries(universeData).forEach(([systemId, systemArray]) => {
      let system = systemArray[0]
        if (system.Name.toLowerCase().includes(term.toLowerCase()) ||
            system.NaturalId.toLowerCase().includes(term.toLowerCase())) {
          results.push({ type: 'system', id: systemId });
        }
      });

      // Search in planets
      Object.entries(planetData).forEach(([systemId, planets]) => {
        planets.forEach(planet => {
          if (planet.PlanetName.toLowerCase().includes(lowerTerm) ||
              planet.PlanetNaturalId.toLowerCase().includes(lowerTerm)) {
            results.push({ type: 'planet', id: planet.PlanetNaturalId, systemId: systemId });
          }
        });
      });
    });

    console.log('Results', results);
    setSearchResults(results);
    highlightSearchResults(results);
    return results;
  }, [universeData, planetData]);


  const handleMaterialSearch = useCallback((searchTerm) => {
    const sanitizedSearchTerm = sanitizeInput(searchTerm);
    const terms = sanitizedSearchTerm.split(/\s+/)
        .filter(term => term.length >= 1); // Only keep terms with 1 or more characters

    let results = [];
    let matchingMaterialIds = [];

    if (terms.length === 0) {
      // Populate results with all planets if no search terms
      Object.entries(planetData).forEach(([systemId, planets]) => {
        planets.forEach(planet => {
          results.push({
            type: 'planet',
            planetId: planet.PlanetNaturalId,
            systemId: systemId
          });
        });
      });
    } else {
      // Find materials matching the search terms
      const matchingMaterials = terms.map(term => {
        const lowerTerm = term.toLowerCase();
        const regex = new RegExp(`\\b${lowerTerm}\\b`, 'i');
        return materials.filter(material =>
          (regex.test(splitCamelCase(material.Name)) || regex.test(material.Ticker.toLowerCase())) &&
          ['ores', 'gases', 'liquids', 'minerals'].includes(material.CategoryName)
        );
      });

      matchingMaterialIds = matchingMaterials.flat().map(material => material.MaterialId);

      // Find planets that have all specified materials
      Object.entries(planetData).forEach(([systemId, planets]) => {
        planets.forEach(planet => {
          const hasAllMaterials = matchingMaterials.every(materialList =>
            materialList.some(material =>
              planet.Resources.some(resource => resource.MaterialId === material.MaterialId)
            )
          );

          if (hasAllMaterials) {
            const planetResources = matchingMaterials.flatMap(materialList =>
              materialList.filter(material =>
                planet.Resources.some(resource => resource.MaterialId === material.MaterialId)
              )
            );

            planetResources.forEach(material => {
              const resource = planet.Resources.find(r => r.MaterialId === material.MaterialId);
              results.push({
                type: 'material',
                id: material.MaterialId,
                name: material.Name,
                ticker: material.Ticker,
                planetId: planet.PlanetNaturalId,
                systemId: systemId,
                factor: resource.Factor,
                resourceType: resource.ResourceType
              });
            });
          }
        });
      });
    }

    const filteredResults = results.filter(result => {
      const planet = planetData[result.systemId].find(p => p.PlanetNaturalId === result.planetId);

      if (!planet) {
        console.warn(`Planet not found for result:`, result);
        return false;
      }

      if (result.type === 'material') {
        // Apply resource type filter
        if (resourceTypeFilter !== 'ALL' && result.resourceType !== resourceTypeFilter) {
          return false;
        }

        // Apply factor check
        let factorCheck;
        if (isRelativeThreshold) {
          let maxFactor;
          if (resourceTypeFilter === 'ALL') {
            // Use global maximum when 'ALL' is selected
            maxFactor = Math.max(...results
              .filter(r => r.type === 'material')
              .map(r => r.factor));
          } else {
            // Use type-specific maximum when a specific type is selected
            maxFactor = Math.max(...results
              .filter(r => r.type === 'material' && r.resourceType === resourceTypeFilter)
              .map(r => r.factor));
          }
          const relativeFactor = result.factor / maxFactor;
          factorCheck = relativeFactor >= resourceThreshold;
        } else {
          factorCheck = result.factor >= resourceThreshold;
        }

        if (!factorCheck) {
          return false;
        }
      }

      const planetTypeCondition =
        (filters.planetType.includes('Rocky') && planet.Surface) ||
        (filters.planetType.includes('Gaseous') && !planet.Surface);

      const planetFertility =
       (filters.planetType.includes('Fertile') && planet.Fertility > -1) ||
       (!filters.planetType.includes('Fertile'));

      const gravityCondition =
        (filters.gravity.includes('Low') && (planet.Gravity < 0.25)) ||
        (filters.gravity.includes('High') && (planet.Gravity >= 2.5)) ||
        ((0.25 <= planet.Gravity) && (planet.Gravity <= 2.5));

      const temperatureCondition =
        (filters.temperature.includes('Low') && (planet.Temperature < -25.0)) ||
        (filters.temperature.includes('High') && (planet.Temperature >= 75.0)) ||
        ((-25.0 <= planet.Temperature) && (planet.Temperature <= 75.0));

      const pressureCondition =
        (filters.pressure.includes('Low') && (planet.Pressure < 0.25)) ||
        (filters.pressure.includes('High') && (planet.Pressure >= 2.0)) ||
        ((0.25 <= planet.Pressure) && (planet.Pressure <= 2.0));

      const cogcCondition = filters.cogcProgram.length === 0 ||
        (planet.HasChamberOfCommerce && (
          filters.cogcProgram.includes('ALL') ||
          filters.cogcProgram.some(selectedProgram => {
            const programs = planet.COGCPrograms || [];
            const sortedPrograms = programs.sort((a, b) => b.StartEpochMs - a.StartEpochMs);
            const currentProgram = sortedPrograms[1] || sortedPrograms[0] || null;
            if (selectedProgram === null) {
              return !currentProgram || currentProgram.ProgramType === null;
            }

            return currentProgram && currentProgram.ProgramType === selectedProgram;
          })
        ));

      return planetTypeCondition && planetFertility && gravityCondition && temperatureCondition &&
             pressureCondition && cogcCondition;
    });

    // Remove duplicates
    const uniqueResults = Array.from(new Set(filteredResults.map(JSON.stringify))).map(JSON.parse);
    // Obtain the highest concentration
    const highestFactorLiquid = uniqueResults
      .filter(result => result.resourceType === 'LIQUID')
      .reduce((max, item) => item.factor > max ? item.factor : max, -Infinity);
    setSearchMaterialConcentrationLiquid(highestFactorLiquid)
    const highestFactorGaseous = uniqueResults
      .filter(result => result.resourceType === 'GASEOUS')
      .reduce((max, item) => item.factor > max ? item.factor : max, -Infinity);
    setSearchMaterialConcentrationGaseous(highestFactorGaseous)
    const highestFactorMineral = uniqueResults
      .filter(result => result.resourceType === 'MINERAL')
      .reduce((max, item) => item.factor > max ? item.factor : max, -Infinity);
    setSearchMaterialConcentrationMineral(highestFactorMineral)

    console.log('Results', uniqueResults);
    setSearchResults(uniqueResults);
    highlightSearchResults(uniqueResults, highestFactorLiquid, highestFactorGaseous, highestFactorMineral);
    setSearchMaterial(matchingMaterialIds);
    return uniqueResults;
  }, [planetData, materials, filters, resourceThreshold, isRelativeThreshold, resourceTypeFilter]);

  const handleCompanySearch = useCallback(async (companyCode) => {
    const sanitizedCompanyCode = sanitizeInput(companyCode);
    try {
      const response = await fetch(`https://rest.fnar.net/company/code/${sanitizedCompanyCode}`);
      const data = await response.json();

      if (data && data.Planets) {
        const results = data.Planets.map(planet => ({
          type: 'company_base',
          planetId: planet.PlanetId,
          planetNaturalId: planet.PlanetNaturalId,
          planetName: planet.PlanetName,
          systemId: Object.keys(planetData).find(systemId =>
          planetData[systemId].some(p => p.PlanetNaturalId === planet.PlanetNaturalId)
          )
        }));

        setSearchResults(results);
        highlightSearchResults(results);
        return results;
      } else {
        return [];
      }
    } catch (error) {
      console.error('Error fetching company data:', error);
      return [];
    }
  }, [planetData]);


  const clearSearch = useCallback(() => {
    setSearchResults([]);
    setSystemSearchTerm('');
    setMaterialSearchTerm('');
    setCompanySearchTerm('');
    setSearchMaterial([]);
    setSearchMaterialConcentrationLiquid([]);
    setSearchMaterialConcentrationGaseous([]);
    setSearchMaterialConcentrationMineral([]);
    clearHighlights();
  }, []);

  const updateFilters = useCallback((newFilters) => {
    setFilters(newFilters);
  }, []);

  const updateSystemSearchTerm = useCallback((term) => {
    setSystemSearchTerm(term);
  }, []);

  const updateMaterialSearchTerm = useCallback((term) => {
    setMaterialSearchTerm(term);
  }, []);

  const updateCompanySearchTerm = useCallback((term) => {
    setCompanySearchTerm(term);
  }, []);

  const toggleCompanySearch = useCallback(() => {
    setIsCompanySearch(prev => !prev);
    clearSearch();
  }, [clearSearch]);


  return (
    <SearchContext.Provider
      value={{
        searchResults,
        searchMaterial,
        searchMaterialConcentrationLiquid,
        searchMaterialConcentrationMineral,
        searchMaterialConcentrationGaseous,
        handleSystemSearch,
        handleMaterialSearch,
        handleCompanySearch,
        clearSearch,
        filters,
        updateFilters,
        systemSearchTerm,
        materialSearchTerm,
        companySearchTerm,
        updateSystemSearchTerm,
        updateMaterialSearchTerm,
        updateCompanySearchTerm,
        resourceThreshold,
        setResourceThreshold,
        isRelativeThreshold,
        setIsRelativeThreshold,
        resourceTypeFilter,
        setResourceTypeFilter,
        isCompanySearch,
        toggleCompanySearch,
      }}
    >
      {children}
    </SearchContext.Provider>
  );
};

--- FILE: src/contexts/SelectionContext.js ---

import React, { createContext, useState, useCallback, useContext } from 'react';
import { highlightSelectedSystem as highlightSelectedSystemUtil } from '../utils/graphUtils';
import { GraphContext } from '../contexts/GraphContext';

export const SelectionContext = createContext();

export const SelectionProvider = ({ children }) => {
  const [isPathfindingEnabled, setIsPathfindingEnabled] = useState(false);
  const [selectedSystem, setSelectedSystem] = useState(null);
  const [pathfindingSelection, setPathfindingSelection] = useState([]);

  const { findShortestPath } = useContext(GraphContext);

  const togglePathfinding = useCallback(() => {
  setIsPathfindingEnabled(prev => {
    if (prev) {
      // If turning off pathfinding, reset the graph state
      highlightSelectedSystemUtil(null, null, [], prev);
    }
    return !prev;
  });
  setPathfindingSelection([]); // Reset selection when toggling
}, []);

const highlightSelectedSystem = useCallback((nextSelectedSystem) => {
  if (isPathfindingEnabled) {
    setPathfindingSelection(prev => {
      let newSelection;
      if (prev.length === 2) {
        // Reset selection if it already has two entries
        newSelection = [nextSelectedSystem];
      } else {
        // Add new selection, keeping at most 2 entries
        newSelection = [...prev, nextSelectedSystem].slice(-2);
      }

      // Always update selectedSystem
      setSelectedSystem(prevSelectedSystem => {
        if (newSelection.length === 1) {
          highlightSelectedSystemUtil(prevSelectedSystem, nextSelectedSystem, newSelection, isPathfindingEnabled);
        }
        return nextSelectedSystem;
      });
      // If we now have 2 systems selected, find the shortest path
        if (newSelection.length === 2) {
          findShortestPath(newSelection[0], newSelection[1]);
        }
      return newSelection;
    });
  } else {
    // Behavior when pathfinding is disabled
    setSelectedSystem(prevSelectedSystem => {
      highlightSelectedSystemUtil(prevSelectedSystem, nextSelectedSystem, [], isPathfindingEnabled);
      return nextSelectedSystem;
    });
  }
}, [isPathfindingEnabled, findShortestPath]);








  return (
    <SelectionContext.Provider
      value={{
        isPathfindingEnabled,
        togglePathfinding,
        selectedSystem,
        pathfindingSelection,
        highlightSelectedSystem
      }}
    >
      {children}
    </SelectionContext.Provider>
  );
};

--- FILE: src/utils/dataPointUtils.js ---

import * as d3 from 'd3';

// Calculate bar dimensions based on node size and zoom level
export const calculateBarDimensions = (nodeWidth, nodeHeight, zoomLevel) => {
  const barWidth = Math.max(2, nodeWidth * 0.15 / zoomLevel); // 15% of node width
  const barHeight = nodeHeight / zoomLevel;
  const xOffset = nodeWidth + (barWidth / 2); // Position right of node
  const yOffset = 0; // Align with top of node

  return {
    barWidth,
    barHeight,
    xOffset,
    yOffset
  };
};

// Calculate color based on density value
export const getDensityColor = (density, maxDensity) => {
  // Color scale from yellow (low) to red (high)
  const colorScale = d3.scaleLinear()
    .domain([0, maxDensity])
    .range(['#FFD700', '#FF4500']); // Gold to Red-Orange

  return colorScale(density);
};

// Calculate bar height based on density value
export const calculateBarHeight = (density, maxDensity, maxHeight) => {
  if (maxDensity === 0) return 0;

  const scale = d3.scaleLinear()
    .domain([0, maxDensity])
    .range([0, maxHeight]);

  return scale(density);
};

// Format density value for display
export const formatDensityValue = (density) => {
  return density.toFixed(2);
};

// Calculate tooltip position
export const calculateTooltipPosition = (event, nodeWidth, nodeHeight) => {
  const { pageX, pageY } = event;
  const tooltipOffset = 10; // Offset from cursor

  return {
    x: pageX + tooltipOffset,
    y: pageY - tooltipOffset
  };
};

// Helper function to determine if a point is near a bar
export const isPointNearBar = (point, barPosition, barDimensions) => {
  const { x, y } = point;
  const { x: barX, y: barY } = barPosition;
  const { barWidth, barHeight } = barDimensions;

  return (
  x >= barX &&
  x <= barX + barWidth &&
  y >= barY &&
  y <= barY + barHeight
  );
};

--- FILE: src/utils/graphUtils.js ---

import * as d3 from 'd3';
import { find_path } from 'dijkstrajs';
import { colors } from '../config/config';

export const findShortestPath = (graph, system1, system2, highlightPath) => {
  if (system1 === 'rect1' || system2 === 'rect1') {
    console.error('Invalid system selection for pathfinding:', system1, system2);
    return;
  }

  const graphNodes = {};
  graph.edges.forEach(edge => {
    if (!graphNodes[edge.start]) graphNodes[edge.start] = {};
    if (!graphNodes[edge.end]) graphNodes[edge.end] = {};
    graphNodes[edge.start][edge.end] = edge.distance;
    graphNodes[edge.end][edge.start] = edge.distance;
  });

  try {
    const path = find_path(graphNodes, system1, system2);
    console.log('Found Path:', path)
    highlightPath(path, system2);
  } catch (error) {
    console.error('Error finding path:', error);
  }
};

// Function to reset all nodes and paths
export const resetGraphState = (nextSelectedSystem) => {
  const svg = d3.select('#map-container svg');
  // Reset all system nodes color and stroke except the background rect and current selection
  svg.selectAll('rect').each(function() {
    const node = d3.select(this);
    const systemId = node.attr('id');
    if (systemId !== 'rect1'
      && systemId !== nextSelectedSystem
      && !node.classed('search-highlight')
      && !node.classed('cogc-overlay-rect')
      && !node.classed('data-overlay')
      ) {
      node
        .attr('fill', colors.resetSystemFill)
        .attr('fill-opacity', colors.resetSystemFillOpacity)
        .attr('stroke', colors.resetSystemStroke)
        .attr('stroke-width', colors.resetSystemStrokeWidth);
    }
  });

  // Reset all paths color and stroke
  svg.selectAll('path').each(function() {
    d3.select(this)
      .attr('stroke', colors.resetPathStroke)
      .attr('stroke-width', colors.resetPathStrokeWidth);
  });
};

// Function to highlight the path
export const highlightPath = (path, systemSelected) => {
  // Reset all system nodes color and stroke except the background rect
  resetGraphState(systemSelected)

  // Highlight systems in the path
  path.forEach(system => {
  const systemNode = d3.select(`#${CSS.escape(system)}`);
    if (!systemNode.classed('search-highlight')) {
      systemNode
        .attr('fill', colors.systemFill)
        .attr('stroke', colors.systemStroke);
    }
  });

  // Highlight paths in the path
  for (let i = 0; i < path.length - 1; i++) {
    const start = path[i];
    const end = path[i + 1];

    d3.selectAll(`path[id*="${start}"][id*="${end}"], path[id*="${end}"][id*="${start}"]`)
      .attr('stroke', colors.pathStroke)
      .attr('stroke-width', colors.pathStrokeWidth);
  }

  // Ensure the start and end systems of the path are highlighted
  if (path.length >= 2) {
    const startSystem = path[0];
    const endSystem = path[path.length - 1];
    highlightSelectedSystem(null, startSystem, [startSystem, endSystem]);
    highlightSelectedSystem(null, endSystem, [startSystem, endSystem]);
  }
};

export const highlightSelectedSystem = (prevSelectedSystem, nextSelectedSystem, pathfindingSelection, isPathfindingEnabled) => {

  // Check if pathfindingSelection is empty, if so reset all nodes
  if (pathfindingSelection.length < 2 && isPathfindingEnabled) {
    resetGraphState(nextSelectedSystem);
  }

  // Reset previous system if it's not part of pathfinding selection
  if (prevSelectedSystem && !pathfindingSelection.includes(prevSelectedSystem)) {
    const prevSystemNode = d3.select(`#${CSS.escape(prevSelectedSystem)}`);
    if (!prevSystemNode.empty() && !prevSystemNode.classed('search-highlight')) {
      prevSystemNode
        .attr('fill', colors.resetSystemFill)
        .attr('fill-opacity', colors.resetSystemFillOpacity)
        .attr('stroke', colors.resetSystemStroke)
        .attr('stroke-width', colors.resetSystemStrokeWidth);
    }
  }

  // Highlight new system
  if (nextSelectedSystem) {
    const nextSystemNode = d3.select(`#${CSS.escape(nextSelectedSystem)}`);
    if (!nextSystemNode.empty() && !nextSystemNode.classed('search-highlight')) {
      nextSystemNode
        .attr('fill', colors.systemFill)
        .attr('stroke', colors.systemStroke)
        .attr('stroke-width', colors.systemStrokeWidth);
    }
  }
};


--- FILE: src/utils/searchUtils.js ---

import * as d3 from 'd3';
import { resetGraphState } from '../utils/graphUtils';
import { colors } from '../config/config';

export const clearHighlights = () => {
  d3.selectAll('.search-highlight')
    .classed('search-highlight', false)
    .attr('fill', colors.resetSystemFill)
    .attr('stroke', colors.resetSystemStroke)
    .attr('stroke-width', colors.resetSystemStrokeWidth);

  resetGraphState();
};

export const highlightSearchResults = (searchResults, highestFactorLiquid, highestFactorGaseous, highestFactorMineral) => {
  console.log(highestFactorLiquid, highestFactorGaseous, highestFactorMineral)
  // Define color scales
  const colorScaleLiquid = d3.scaleLinear()
    .domain([0, highestFactorLiquid])
    .range([colors.searchSystemFillLowLiquid, colors.searchSystemFillLiquid]);
  const colorScaleGaseous = d3.scaleLinear()
    .domain([0, highestFactorGaseous])
    .range([colors.searchSystemFillLowGaseous, colors.searchSystemFillGaseous]);
  const colorScaleMineral = d3.scaleLinear()
    .domain([0, highestFactorMineral])
    .range([colors.searchSystemFillLowMineral, colors.searchSystemFillMineral]);

  if (searchResults.length > 0) {
    // Reset all systems to default state
    clearHighlights();

    // Track the best resource for each system
    const systemBestResource = {};

    // First pass: determine the best resource to highlight for each system
    searchResults.forEach(result => {
      if (result.type === 'material') {
        const systemId = result.systemId;
        if (!systemBestResource[systemId]) {
          systemBestResource[systemId] = result;
        } else {
          const current = systemBestResource[systemId];
          // Simply keep the resource with the highest concentration
          if (result.factor > current.factor) {
            systemBestResource[systemId] = result;
          }
        }
      } else if (result.type === 'company_base') {
        const systemId = result.systemId;
        if (!systemBestResource[systemId]) {
          systemBestResource[systemId] = result;
        }
      }
    });

    // Second pass: highlight systems based on the best resource
    searchResults.forEach(result => {
      let highlightSystemNode = {};
      let fillColor = colors.searchSystemFill;
      let systemId;

      if (result.type === 'system') {
        systemId = result.id;
        highlightSystemNode = d3.select(`#${CSS.escape(systemId)}`);
      } else if (result.type === 'planet') {
        systemId = result.systemId;
        highlightSystemNode = d3.select(`#${CSS.escape(systemId)}`);
      } else if (result.type === 'material') {
        systemId = result.systemId;
        const bestForSystem = systemBestResource[systemId];

        if (result === bestForSystem) {
          if (result.resourceType === 'LIQUID') {
            fillColor = colorScaleLiquid(result.factor);
          } else if (result.resourceType === 'GASEOUS') {
            fillColor = colorScaleGaseous(result.factor);
          } else {
            fillColor = colorScaleMineral(result.factor);
          }
          highlightSystemNode = d3.select(`#${CSS.escape(systemId)}`);
        } else {
          // Skip this result as it's not the best for the system
          return;
        }
      } else if (result.type === 'company_base') {
        systemId = result.systemId;
        highlightSystemNode = d3.select(`#${CSS.escape(systemId)}`);
      }

      if (!highlightSystemNode.empty()) {
        highlightSystemNode
          .attr('fill', fillColor)
          .attr('stroke', colors.searchSystemStroke)
          .attr('stroke-width', colors.searchSystemStrokeWidth)
          .attr('fill-opacity', 1.0)
          .classed('search-highlight', true);
      }
    });
  }
};

--- FILE: src/utils/svgUtils.js ---

import * as d3 from 'd3';
import React from 'react';
import ReactDOMServer from 'react-dom/server';
import { BadgeCent, Anchor, Truck, BookOpen, Globe } from 'lucide-react';
import { colors } from '../config/config';

let universeData = null;
let planetData = null;
let universeMaxConcentrations = null;

// Function to fetch and process the universe and planet data
const fetchData = async () => {
  try {
    const [universeResponse, planetResponse] = await Promise.all([
      fetch('prun_universe_data.json'),
      fetch('planet_data.json')
    ]);
    const universeJson = await universeResponse.json();
    const planetJson = await planetResponse.json();

    universeData = Object.fromEntries(universeJson.map(system => [system.SystemId, system]));

    // Group planets by SystemId
    planetData = planetJson.reduce((acc, planet) => {
      if (!acc[planet.SystemId]) {
        acc[planet.SystemId] = [];
      }
      acc[planet.SystemId].push(planet);
      return acc;
    }, {});

    universeMaxConcentrations = calculateMaxConcentrations(Object.values(planetData).flat());

    console.log('Universe and planet data loaded');
  } catch (error) {
    console.error('Error loading data:', error);
  }
};

// Call this function when the application initializes
fetchData();

const calculateMaxConcentrations = (planets) => {
  const maxConc = {};

  planets.forEach(planet => {
    planet.Resources.forEach(resource => {
      const key = `${resource.MaterialId}-${resource.ResourceType}`;
      if (!maxConc[key] || resource.Factor > maxConc[key]) {
        maxConc[key] = resource.Factor;
      }
    });
  });

  return maxConc;
};

// Function to create facility indicator
const createFacilityIndicator = (hasFeature, IconComponent) => {
  const color = hasFeature ? '#f7a600' : '#3d3846';
  const iconElement = React.createElement(IconComponent, {
    size: 18,
    color: color,
    strokeWidth: 1.5,
    style: { marginRight: '2px' }
  });

  return ReactDOMServer.renderToString(iconElement);
};

const determinePlanetTier = (buildRequirements) => {
  const tier4 = ['TSH'];
  const tier3 = ['MGC', 'BL', 'HSE', 'INS'];
  const tier2 = ['SEA'];

  let highestTier = 1; // Start with the lowest tier

  for (const requirement of buildRequirements) {
    const ticker = requirement.MaterialTicker;
    if (tier4.includes(ticker)) {
      return 4; // If we find a Tier 4 material, we can return immediately as it's the highest
    } else if (tier3.includes(ticker) && highestTier < 3) {
      highestTier = 3;
    } else if (tier2.includes(ticker) && highestTier < 2) {
      highestTier = 2;
    }
  }

  return highestTier;
};


// Function to convert COGC program type to readable format
const formatCOGCProgram = (programType) => {
  if (!programType) return 'No active Program';
  return programType.split('_').map(word => word.charAt(0) + word.slice(1).toLowerCase()).join(' ');
};

// Function to create PlanetTier indicator
const createPlanetTierIndicator = (tier) => {
  const maxTier = 4;
  const filledStar = '★';
  const emptyStar = '☆';
  const stars = filledStar.repeat(maxTier - tier) + emptyStar.repeat(Math.max(0, tier - 1));
  return `<span class="planet-tier">${stars}</span>`;
};

// Function to create and show the info panel
const showInfoPanel = (rect, x, y, searchResults, materials, isRelativeThreshold) => {
  console.log(searchResults)
  const isPlanetInSearchResults = (planetId) => {
    return searchResults.some(result =>
      (result.type === 'planet' && result.planetId === planetId) ||
      (result.type === 'material' && result.planetId === planetId)
    );
  };

  const findMatchingMaterials = (planetId) => {
    return searchResults.filter(result =>
      result.type === 'material' && result.planetId === planetId
    );
  };

  const createConcentrationBar = (concentration, materialId, resourceType, isRelative, maxConcentrations) => {
    const key = `${materialId}-${resourceType}`;
    const maxConcentration = maxConcentrations[key] || concentration;
    const percentage = isRelative ? (concentration / maxConcentration) * 100 : concentration * 100;
    const hue = (percentage / 100) * 120; // 0 is red, 120 is green
    const backgroundColor = `hsl(${hue}, 100%, 50%)`;

    return `
    <div class="concentration-bar-container" style="width: 100px; background-color: #ddd; height: 10px; margin-left: 5px;">
      <div class="concentration-bar" style="width: ${percentage}%; background-color: ${backgroundColor}; height: 100%;"></div>
    </div>
    <span class="resource-percentage">${percentage.toFixed(2)}%</span>
  `;
  };


  const systemId = rect.attr('id').replace('#', '');
  const system = universeData ? universeData[systemId] : null;
  const planets = planetData ? planetData[systemId] : null;

  if (!system || !planets) {
    console.error('System or planet data not found for:', systemId);
    return;
  }

  const infoPanel = d3.select('body').append('div')
    .attr('class', 'info-panel')
    .style('left', `${x}px`)
    .style('top', `${y}px`)
    .style('display', 'block');

  let content = `<h3>${system.Name} (${system.NaturalId})</h3>`;
  content += `<ul class="planet-list">`;

  // Sort planets alphabetically by PlanetNaturalId
  const sortedPlanets = planets.sort((a, b) => a.PlanetNaturalId.localeCompare(b.PlanetNaturalId));

  sortedPlanets.forEach(planet => {
    let planetTier = determinePlanetTier(planet.BuildRequirements);
    const isHighlighted = isPlanetInSearchResults(planet.PlanetNaturalId);
    const matchingMaterials = findMatchingMaterials(planet.PlanetNaturalId);

    content += `<li class="${isHighlighted ? 'highlighted-planet' : ''}">
      <div class="planet-info">
        <div class="planet-name-tier">
          <span class="planet-name">${planet.PlanetName} (${planet.PlanetNaturalId})</span>
          ${createPlanetTierIndicator(planetTier)}
        </div>
        <div class="facility-indicators">
          ${createFacilityIndicator(planet.HasLocalMarket, BadgeCent)}
          ${createFacilityIndicator(planet.HasChamberOfCommerce, Globe)}
          ${createFacilityIndicator(planet.HasWarehouse, Truck)}
          ${createFacilityIndicator(planet.HasAdministrationCenter, BookOpen)}
          ${createFacilityIndicator(planet.HasShipyard, Anchor)}
        </div>
      </div>`;
    if (planet.HasChamberOfCommerce) {
      let programType
      if (planet.COGCPrograms.length > 0) {
        const programs = planet.COGCPrograms;
        const sortedPrograms = programs.sort((a, b) => b.StartEpochMs - a.StartEpochMs);
        const currentProgram = sortedPrograms[1] || sortedPrograms[0] || null;
        programType = currentProgram.ProgramType;
      }
      const formattedProgram = formatCOGCProgram(programType);
      content += `<div class="cogc-program">CoGC: ${formattedProgram}</div>`;
    }
    // Add resource bars for matching materials
    if (matchingMaterials.length > 0) {
      content += `<div class="matching-resources">`;
      matchingMaterials.forEach(material => {
        const materialInfo = materials.find(m => m.MaterialId === material.id);
        const planetResource = planet.Resources.find(r => r.MaterialId === material.id);
        if (materialInfo && planetResource) {
          content += `
            <div class="resource-item" style="display: flex; align-items: center; margin-bottom: 5px;">
              <span class="resource-name" style="margin-right: 5px;">${materialInfo.Ticker}</span>
              ${createConcentrationBar(
                planetResource.Factor,
                planetResource.MaterialId,
                planetResource.ResourceType,
                isRelativeThreshold,
                universeMaxConcentrations
              )}
            </div>
          `;
        }
      });
      content += `</div>`;
    }
    content += `</li>`;
  });

  content += `</ul>`;
  infoPanel.html(content);
};

// Function to hide the info panel
const hideInfoPanel = () => {
  d3.select('.info-panel').remove();
};

// Function to add mouseover and mouseout events for animation
export const addMouseEvents = (g, searchResults, materials, isRelativeThreshold) => {
  g.selectAll('rect').each(function() {
    const rect = d3.select(this);
    const originalSize = { width: +rect.attr('width'), height: +rect.attr('height') };
    const originalPos = { x: +rect.attr('x'), y: +rect.attr('y') };
    let hoverTimer;
    let overlayOriginalSize, overlayOriginalPos;

    rect.on('mouseover.system', function(event) {
      if (rect.attr('id') === 'rect1' || d3.select(event.target).classed('data-overlay')) return;
      rect
        .attr('fill-opacity', 1)
        .attr('stroke-opacity', 1)
        .transition()
        .duration(200)
        .attr('width', originalSize.width * 2)
        .attr('height', originalSize.height * 2)
        .attr('x', originalPos.x - originalSize.width / 2)
        .attr('y', originalPos.y - originalSize.height / 2);

      const overlayRect = rect.property('cogcOverlayRect');

      if (overlayRect) {
        overlayOriginalSize = {
          width: +overlayRect.attr('width'),
          height: +overlayRect.attr('height')
        };
        overlayOriginalPos = {
          x: +overlayRect.attr('x'),
          y: +overlayRect.attr('y')
        };

        overlayRect
          .transition()
          .duration(200)
          .attr('width', overlayOriginalSize.width + originalSize.width)
          .attr('height', overlayOriginalSize.height + originalSize.width)
          .attr('x', overlayOriginalPos.x - originalSize.width / 2)
          .attr('y', overlayOriginalPos.y - originalSize.height / 2);
      }

      // Set timer for info panel
      hoverTimer = setTimeout(() => {
        const [x, y] = d3.pointer(event);
        showInfoPanel(rect, x, y, searchResults, materials, isRelativeThreshold);
      }, 400);

    }).on('mouseout.system', function(event) {
      if (rect.attr('id') === 'rect1') return;
      rect.transition()
        .duration(200)
        .attr('width', originalSize.width)
        .attr('height', originalSize.height)
        .attr('x', originalPos.x)
        .attr('y', originalPos.y)
        .attr('fill-opacity', rect.classed('search-highlight') ? 1 : colors.resetSystemFillOpacity);

      // Reset the overlay rect if it exists
      const overlayRect = rect.property('cogcOverlayRect');
      if (overlayRect) {
        overlayRect
          .transition()
          .duration(200)
          .attr('width', overlayOriginalSize.width)
          .attr('height', overlayOriginalSize.height)
          .attr('x', overlayOriginalPos.x)
          .attr('y', overlayOriginalPos.y);
      }

      // Clear timer and hide info panel
      clearTimeout(hoverTimer);
      hideInfoPanel();
    });
  });
};

--- FILE: src/components/DataPointOverlay.jsx ---

import React, { useEffect, useCallback } from 'react';
import * as d3 from 'd3';
import { useDataPoints } from '../contexts/DataPointContext';

const DataPointOverlay = ({ mapRef }) => {
  const {
    meteorDensityData,
    luminosityData,
    systemNames,
    isOverlayVisible,
    isLoading,
    error,
    maxValues
  } = useDataPoints();

  const renderOverlay = useCallback(() => {
    if (!mapRef?.current?.g) return;

    // Clean up existing elements
    mapRef.current.g.selectAll('.meteor-density-group').remove();
    mapRef.current.g.selectAll('.system-name-label').remove();

    if (!isOverlayVisible || isLoading || error) {
      return;
    }

    const { g } = mapRef.current;
    const transform = d3.zoomTransform(g.node());
    const zoomLevel = transform?.k || 1;

    // Color scales for both metrics
    const densityColorScale = d3.scaleSequential()
      .domain([0, maxValues.density])
      .interpolator(d3.interpolatePuBu);

    const luminosityColorScale = d3.scaleSequential()
      .domain([0, maxValues.luminosity])
      .interpolator(d3.interpolateWarm);

    g.selectAll('rect:not(.meteor-density-bar)').each(function() {
      const node = d3.select(this);
      const systemId = node.attr('id');

      if (systemId === 'rect1') return;

      const density = meteorDensityData[systemId] || 0;
      const luminosity = luminosityData[systemId] || 0;

      const nodeWidth = parseFloat(node.attr('width'));
      const nodeHeight = parseFloat(node.attr('height'));
      const nodeX = parseFloat(node.attr('x'));
      const nodeY = parseFloat(node.attr('y'));

      const systemGroup = g.append('g')
        .attr('class', 'meteor-density-group');

      // Calculate bar dimensions
      const barWidth = Math.max(3, nodeWidth * 0.2 / zoomLevel);
      const maxBarHeight = nodeHeight;
      const barSpacing = barWidth * 0.5;

      // Create log scale for luminosity bar height
      const luminosityLogScale = d3.scaleLog()
        .domain([0.01, maxValues.luminosity]) // Using 0.1 as minimum to avoid log(0)
        .range([0, maxBarHeight]);

      // Density bar
      const densityHeight = maxBarHeight * (density / maxValues.density);
      const densityX = nodeX + nodeWidth * 1.2;

      // Background for density bar
      systemGroup.append('rect')
        .attr('class', 'meteor-density-bar-background data-overlay')
        .attr('x', densityX)
        .attr('y', nodeY)
        .attr('width', barWidth)
        .attr('height', maxBarHeight)
        .attr('fill', '#2a2a2a')
        .attr('opacity', 0.5);

      // Density bar
      const densityBar = systemGroup.append('rect')
        .attr('class', 'meteor-density-bar data-overlay')
        .attr('x', densityX)
        .attr('y', nodeY + maxBarHeight - densityHeight)
        .attr('width', barWidth)
        .attr('height', densityHeight)
        .attr('fill', densityColorScale(density))
        .attr('opacity', 0.8);

      // Luminosity bar
      const luminosityHeight = luminosityLogScale(Math.max(0.1, luminosity));
      const luminosityX = densityX + barWidth + barSpacing;

      // Background for luminosity bar
      systemGroup.append('rect')
        .attr('class', 'luminosity-bar-background data-overlay')
        .attr('x', luminosityX)
        .attr('y', nodeY)
        .attr('width', barWidth)
        .attr('height', maxBarHeight)
        .attr('fill', '#2a2a2a')
        .attr('opacity', 0.5);

      // Luminosity bar
      const luminosityBar = systemGroup.append('rect')
        .attr('class', 'luminosity-bar data-overlay')
        .attr('x', luminosityX)
        .attr('y', nodeY + maxBarHeight - luminosityHeight)
        .attr('width', barWidth)
        .attr('height', luminosityHeight)
        .attr('fill', luminosityColorScale(luminosity))
        .attr('opacity', 0.8);

      // System name label
      systemGroup.append('text')
        .attr('class', 'system-name-label data-overlay')
        .attr('x', nodeX + (nodeWidth / 2))
        .attr('y', nodeY + nodeHeight + 2)
        .attr('fill', '#CCCCCC')
        .attr('stroke', '#000000')
        .attr('stroke-width', 1 / zoomLevel)
        .attr('paint-order', 'stroke')
        .attr('font-size', '6px')
        .attr('text-anchor', 'middle')
        .attr('dominant-baseline', 'hanging')
        .style('pointer-events', 'none')
        .text(systemNames[systemId] || systemId);

      // Add hover interactions for both bars
      const addBarHoverEffects = (bar, dataType, value, colorScale) => {
        bar.on('mouseover.data', function(event) {
          event.stopPropagation();
          d3.select(this)
            .attr('opacity', 1)
            .attr('stroke', '#ffffff')
            .attr('stroke-width', 1 / zoomLevel);

          d3.select('body')
            .append('div')
            .attr('class', 'data-overlay-tooltip')
            .style('position', 'absolute')
            .style('left', `${event.pageX + 10}px`)
            .style('top', `${event.pageY - 10}px`)
            .style('background-color', 'rgba(0, 0, 0, 0.8)')
            .style('color', 'white')
            .style('padding', '5px')
            .style('border-radius', '4px')
            .style('font-size', '12px')
            .style('pointer-events', 'none')
            .html(`
              <div style="background: rgba(0,0,0,0.9); padding: 8px; border-radius: 4px; border: 1px solid #444">
                <div style="font-weight: bold; color: #f7a600; margin-bottom: 4px">${systemNames[systemId] || systemId}</div>
                <div>${dataType}: ${value.toFixed(3)}</div>
                <div style="color: #aaa; font-size: 11px; margin-top: 2px">
                  Relative to Max (${maxValues[dataType.toLowerCase()].toFixed(2)}):
                  ${((value / maxValues[dataType.toLowerCase()]) * 100).toFixed(1)}%
                </div>
              </div>
            `);
        })
        .on('mouseout.data', function(event) {
          event.stopPropagation();
          d3.select(this)
            .attr('opacity', 0.8)
            .attr('stroke', 'none');
          d3.selectAll('.data-overlay-tooltip').remove();
        });
      };

      addBarHoverEffects(densityBar, 'Density', density, densityColorScale);
      addBarHoverEffects(luminosityBar, 'Luminosity', luminosity, luminosityColorScale);
    });
  }, [mapRef, isOverlayVisible, isLoading, error, meteorDensityData, luminosityData, systemNames, maxValues]);

  useEffect(() => {
    renderOverlay();
  }, [renderOverlay]);

  useEffect(() => {
    if (!mapRef?.current?.svg) return;

    // Capture the current svg reference
    const svg = mapRef.current.svg;

    const handleZoom = () => {
      renderOverlay();
    };

    svg.on('zoom.overlay', handleZoom);

    return () => {
      // Use the captured reference in cleanup
      svg.on('zoom.overlay', null);
    };
  }, [mapRef, renderOverlay]);

  return null;
};

export default React.memo(DataPointOverlay);

--- FILE: src/components/FilterCategories.css ---

.toggle-token {
  font-size: 12px;
  padding: 5px 9px;
  margin: 2px;
  border: 1px solid #ccc;
  border-radius: 15px;
  background-color: #f0f0f0;
  color: #333;
  cursor: pointer;
  transition: all 0.3s ease;
  position: relative;
}

.toggle-token1 {
  padding: 5px 3px 5px 9px;
  border-radius: 15px 0px 0px 15px;
  margin: 2px 1px 2px 2px;
}

.toggle-token2 {
  padding: 5px 9px 5px 3px;
  border-radius: 0px 15px 15px 0px;
  margin: 2px 2px 2px 1px;
}

.toggle-token.active {
  background-color: #f7a600;
  color: white;
  border-color: #f7a600;
}

.filter-category select {
  padding: 5px 10px 5px 3px;
  border-radius: 0px 15px 15px 0px;
  margin: 2px 2px 2px 1px;
  border: 1px solid #ccc;
  background-color: #f0f0f0;
  color: #333;
  font-size: 12px;
  cursor: pointer;
  transition: all 0.3s ease;
}

.filter-category select:hover {
  border-color: #999;
}

.filter-category select:focus {
  outline: none;
  border-color: #f7a600;
  box-shadow: 0 0 0 2px rgba(247, 166, 0, 0.2);
}

.toggle-group {
  display: flex;
  flex-wrap: wrap;
}

.toggle-token:hover::after {
  content: attr(data-tooltip);
  position: absolute;
  bottom: -100%;
  left: 50%;
  transform: translateX(-50%);
  background-color: #333;
  color: white;
  padding: 5px 10px;
  border-radius: 4px;
  font-size: 12px;
  white-space: nowrap;
  z-index: 1000;
  pointer-events: none;
}

.pathfinding-toggle-container .toggle-token[data-tooltip]::after {
  position: absolute;
  left: 30%;
  bottom: -200%;
  width: max-content;
  max-width: 125px;
  white-space: pre-wrap;
}

.resource-threshold-input {
  width: 50px;
  padding: 5px;
  margin-right: 5px;
  border: 1px solid #ccc;
  border-radius: 14px;
  background-color: #333;
  color: #fff;
}

.resource-threshold-value {
  font-size: 14px;
  color: #f7a600;
}

.resource-threshold-controls {
  display: flex;
  align-items: center;
  gap: 10px;
}

.resource-type-filter select {
  padding: 5px;
  border-radius: 15px;
  border: 1px solid #ccc;
  background-color: #333;
  color: #fff;
  font-size: 12px;
}

@media (max-width: 820px) {
  .toggle-token {
    font-size: 10px;
    padding: 2px 5px;
  }

  .toggle-token:hover::after {
    font-size: 10px;
    padding: 3px 6px;
  }

  .filter-category select {
    padding: 2px 5px;
    border-radius: 13px;
    font-size: 10px;
  }

  .resource-threshold-input {
    width: 50px;
    padding: 3px;
    font-size: 10px;
  }

  .resource-threshold-value {
    font-size: 10px;
  }

  .resource-threshold-controls {
    flex-wrap: wrap;
  }
}

--- FILE: src/components/FilterCategories.jsx ---

import React, { useContext, useState } from 'react';
import { SearchContext } from '../contexts/SearchContext';
import { useCogcOverlay } from '../contexts/CogcOverlayContext';
import { cogcPrograms } from '../constants/cogcPrograms';
import ResourceThresholdFilter from './ResourceThresholdFilter';

const ToggleToken = ({ label, active, onClick, tooltip, className }) => (
  <button
    className={`toggle-token ${active ? 'active' : ''} ${className}`}
    onClick={onClick}
    data-tooltip={tooltip}
  >
    {label}
  </button>
);

const FilterCategory = ({ title, options, mouseoverText, selectedOptions, onChange }) => (
  <div className="filter-category">
    <h4>{title}</h4>
    <div className="toggle-group">
      {options.map((option, index) => (
        <ToggleToken
          key={option}
          label={option}
          active={selectedOptions.includes(option)}
          onClick={() => onChange(option)}
          tooltip={mouseoverText[index] || option}
          className={`toggle-token${index + 1}`}
        />
      ))}
    </div>
  </div>
);

const CogcFilter = ({ active, program, onToggle, onProgramChange }) => {
  const { setOverlayProgram } = useCogcOverlay();

  const handleProgramChange = (value) => {
    onProgramChange(value);
    if (value !== 'ALL' && value !== null) {
      setOverlayProgram(value);
    } else {
      setOverlayProgram(null);
    }
  };

  return (
    <div className="filter-category">
      <h4>Cogc Program</h4>
      <div className="cogc-filter-controls">
        <ToggleToken
          label="Cogc"
          active={active}
          onClick={onToggle}
          tooltip="Toggle Cogc Program filter, dropdown activates an overlay"
          className={`toggle-token1`}
        />
        <select
          value={program}
          onChange={(e) => handleProgramChange(e.target.value)}
        >
          {cogcPrograms.map((program) => (
            <option key={program.value} value={program.display}>
              {program.display}
            </option>
          ))}
        </select>
      </div>
    </div>
  );
};

const FilterCategories = () => {
  const { filters, updateFilters } = useContext(SearchContext);
  const [cogcActive, setCogcActive] = useState(false);
  const { overlayProgram } = useCogcOverlay();

  const handleChange = (category, option) => {
    const newFilters = {
      ...filters,
      [category]: filters[category].includes(option)
        ? filters[category].filter(item => item !== option)
        : [...filters[category], option]
    };
    updateFilters(newFilters);
  };

  const handleCogcToggle = (value) => {
    setCogcActive(!cogcActive);
    if (!cogcActive) {
      // Find the corresponding value for the current overlayProgram
      const programObject = cogcPrograms.find(program => program.display === overlayProgram);
      let programValue;

      if (programObject) {
        programValue = programObject.value;
      } else if (overlayProgram === null || overlayProgram === undefined) {
        programValue = 'ALL'; // Default to 'ALL' if no overlay program is set
      } else {
        console.warn(`No matching program found for: ${overlayProgram}`);
        programValue = 'ALL'; // Default to 'ALL' if no match is found
      }
      updateFilters({ ...filters, cogcProgram: [programValue] });
    } else {
      updateFilters({ ...filters, cogcProgram: [] });
    }
  };

  const handleCogcProgramChange = (value) => {
      if(cogcActive) {
        const valueToSet = cogcPrograms.find(program => program.display === value);
        updateFilters({ ...filters, cogcProgram: [valueToSet.value] });
      } else {
        updateFilters({ ...filters, cogcProgram: [] });
      }

  };

  return (
    <div className="filter-categories">
      <FilterCategory
        title="Planet Type"
        options={['Rocky', 'Gaseous', 'Fertile']}
        mouseoverText={['MCG', 'AEF', 'Fertile Planets']}
        selectedOptions={filters.planetType}
        onChange={option => handleChange('planetType', option)}
      />
      <FilterCategory
        title="Gravity"
        options={['Low', 'High']}
        mouseoverText={['MGC', 'BL']}
        selectedOptions={filters.gravity}
        onChange={option => handleChange('gravity', option)}
      />
      <FilterCategory
        title="Temperature"
        options={['Low', 'High']}
        mouseoverText={['INS', 'TSH']}
        selectedOptions={filters.temperature}
        onChange={option => handleChange('temperature', option)}
      />
      <FilterCategory
        title="Pressure"
        options={['Low', 'High']}
        mouseoverText={['SEA', 'HSE']}
        selectedOptions={filters.pressure}
        onChange={option => handleChange('pressure', option)}
      />
      <CogcFilter
        active={cogcActive}
        onToggle={handleCogcToggle}
        onProgramChange={handleCogcProgramChange}
      />
      <ResourceThresholdFilter />
    </div>
  );
};

export default FilterCategories;

--- FILE: src/components/InfoTooltip.jsx ---

import React, { useState } from 'react';
import { Info, BadgeCent, Globe, Truck, BookOpen, Anchor, Earth, Cloud } from 'lucide-react';

const InfoTooltip = () => {
  const [isTooltipVisible, setIsTooltipVisible] = useState(false);

  return (
    <div className="info-tooltip-container" style={{ position: 'relative' }}>
      <Info
        size={24}
        color="#f7a600"
        style={{ cursor: 'pointer' }}
        onMouseEnter={() => setIsTooltipVisible(true)}
        onMouseLeave={() => setIsTooltipVisible(false)}
      />
      {isTooltipVisible && (
        <div className="tooltip" style={{
          position: 'absolute',
          top: '100%',
          right: 0,
          backgroundColor: '#333',
          color: 'white',
          padding: '10px',
          borderRadius: '4px',
          boxShadow: '0 2px 5px rgba(0,0,0,0.2)',
          width: '300px',
          zIndex: 1000,
          border: '2px solid #222222',
        }}>
          <h4 style={{ margin: '0 0 10px 0' }}>Symbol Legend</h4>
          <h5 style={{ margin: '10px 0 5px 0' }}>Planet Types:</h5>
          <ul style={{ padding: 0, margin: 0, listStyle: 'none' }}>
            <li><Earth size={16} style={{marginRight: '5px', color: '#f7a600'}} /> Rocky Planet</li>
            <li><Cloud size={16} style={{marginRight: '5px', color: '#f7a600'}} /> Gas Giant</li>
          </ul>
          <h5 style={{ margin: '10px 0 5px 0' }}>Resources:</h5>
          <ul style={{ padding: 0, margin: 0, listStyle: 'none' }}>
            <li>🪨 - Mineral resource</li>
            <li>💨 - Gaseous resource</li>
            <li>💧 - Liquid resource</li>
          </ul>
          <h5 style={{ margin: '10px 0 5px 0' }}>Facilities:</h5>
          <ul style={{ padding: 0, margin: 0, listStyle: 'none' }}>
            <li><BadgeCent size={16} style={{marginRight: '5px', color: '#f7a600'}} /> - Local Market</li>
            <li><Globe size={16} style={{marginRight: '5px', color: '#f7a600'}} /> - Chamber of Commerce</li>
            <li><Truck size={16} style={{marginRight: '5px', color: '#f7a600'}} /> - Warehouse</li>
            <li><BookOpen size={16} style={{marginRight: '5px', color: '#f7a600'}} /> - Administration Center</li>
            <li><Anchor size={16} style={{marginRight: '5px', color: '#f7a600'}} /> - Shipyard</li>
          </ul>
          <h5 style={{ margin: '10px 0 5px 0' }}>Planet Tiers:</h5>
          <ul style={{ padding: 0, margin: 0, listStyle: 'none' }}>
            <li>★★★ - Tier 1: No special materials required</li>
            <li>★★☆ - Tier 2: Requires SEA</li>
            <li>★☆☆ - Tier 3: Requires MGC, BL, HSE, or INS</li>
            <li>☆☆☆ - Tier 4: Requires TSH</li>
          </ul>
          <p style={{ margin: '10px 0 0 0' }}>
            Higher tier planets require more advanced materials to establish bases. Tier is determined by the most advanced material required.
          </p>
        </div>
      )}
    </div>
  );
};

export default InfoTooltip;

--- FILE: src/components/MaterialSearchField.jsx ---

import React, { useState, useContext } from 'react';
import { SearchContext } from '../contexts/SearchContext';

const MaterialSearchField = () => {
  const [notification, setNotification] = useState('');
  const { handleMaterialSearch, materialSearchTerm, updateMaterialSearchTerm } = useContext(SearchContext);

  const onSearch = (e) => {
    e.preventDefault();
    const result = handleMaterialSearch(materialSearchTerm);
    if (result.length === 0) {
      setNotification('No matches found');
      setTimeout(() => setNotification(''), 3000); // Clear notification after 3 seconds
    } else {
      setNotification('');
    }
  };

  return (
    <div className="material-search-field">
      <form onSubmit={onSearch}>
        <input
          type="text"
          value={materialSearchTerm}
          onChange={(e) => updateMaterialSearchTerm(e.target.value)}
          placeholder="Search resource, filters..."
        />
        <button type="submit" className="search-button material-search">Search</button>
      </form>
      {notification && <div className="search-notification">{notification}</div>}
    </div>
  );
};

export default MaterialSearchField;

--- FILE: src/components/MeteorDensityToggle.jsx ---

import React from 'react';
import { useDataPoints } from '../contexts/DataPointContext';

const MeteorDensityToggle = () => {
  const { isOverlayVisible, toggleOverlayVisibility } = useDataPoints();

  return (
    <div className="meteor-density-toggle">
      <button
        className={`toggle-token ${isOverlayVisible ? 'active' : ''}`}
        onClick={toggleOverlayVisibility}
        data-tooltip="Toggle overlay with meteor density and system names"
      >
      </button>
    </div>
  );
};

export default MeteorDensityToggle;

--- FILE: src/components/Node.jsx ---

// Example Node component for handling individual node interactions
import React from 'react';
import * as d3 from 'd3';

const Node = ({ id, x, y, width, height, fill, stroke }) => {
  useEffect(() => {
    const node = d3.select(`#${id}`);
    const originalSize = { width, height };
    const originalPos = { x, y };

    node.on('mouseover', function() {
      if (id === 'rect1') return;
      node
        .attr('fill-opacity', 1)
        .attr('stroke-opacity', 1)
        .transition()
        .duration(200)
        .attr('width', originalSize.width * 2)
        .attr('height', originalSize.height * 2)
        .attr('x', originalPos.x - originalSize.width / 2)
        .attr('y', originalPos.y - originalSize.height / 2);
    }).on('mouseout', function() {
      if (id === 'rect1') return;
      node.transition()
        .duration(200)
        .attr('width', originalSize.width)
        .attr('height', originalSize.height)
        .attr('x', originalPos.x)
        .attr('y', originalPos.y)
        .attr('fill-opacity', 0.8);
    });

    // Add click event if needed
  }, [id, x, y, width, height]);

  return null; // This component is for logic only
};

export default Node;


--- FILE: src/components/Path.jsx ---

// Example Path component for handling individual path interactions
import React from 'react';
import * as d3 from 'd3';

const Path = ({ id, stroke, strokeWidth }) => {
  useEffect(() => {
    const path = d3.select(`#${id}`);

    // Add interactions if needed
  }, [id, stroke, strokeWidth]);

  return null; // This component is for logic only
};

export default Path;


--- FILE: src/components/PathfindingToggle.jsx ---

import React, { useContext } from 'react';
import { SelectionContext } from '../contexts/SelectionContext';

const PathfindingToggle = () => {
  const { isPathfindingEnabled, togglePathfinding } = useContext(SelectionContext);

  return (
    <div className="pathfinding-toggle">
      <button
        className={`toggle-token ${isPathfindingEnabled ? 'active' : ''}`}
        onClick={togglePathfinding}
        data-tooltip="Toggle pathfinding mode"
      >
      </button>
    </div>
  );
};

export default PathfindingToggle;


--- FILE: src/components/ResourceThresholdFilter.jsx ---

import React, { useContext } from 'react';
import { SearchContext } from '../contexts/SearchContext';

const ToggleToken = ({ label, active, onClick, tooltip }) => (
  <button
    className={`toggle-token ${active ? 'active' : ''}`}
    onClick={onClick}
    data-tooltip={tooltip}
  >
    {label}
  </button>
);

const ResourceThresholdFilter = () => {
  const {
    resourceThreshold,
    setResourceThreshold,
    isRelativeThreshold,
    setIsRelativeThreshold,
    resourceTypeFilter,
    setResourceTypeFilter
  } = useContext(SearchContext);

  const handleThresholdChange = (event) => {
    const value = parseFloat(event.target.value);
    setResourceThreshold(isNaN(value) ? 0 : value);
  };

  const handleToggleChange = () => {
    setIsRelativeThreshold(!isRelativeThreshold);
  };

  const handleResourceTypeChange = (event) => {
    setResourceTypeFilter(event.target.value);
  };

  return (
    <div className="filter-category">
      <h4>Resource Filters</h4>
      <div className="resource-filter-controls">
        <div className="resource-threshold-controls">
          <input
            type="number"
            min="0"
            max="1"
            step="0.05"
            value={resourceThreshold}
            onChange={handleThresholdChange}
            className="resource-threshold-input"
          />
          <span className="resource-threshold-value">{(resourceThreshold * 100).toFixed(0)}%</span>
          <ToggleToken
            label="Relative"
            active={isRelativeThreshold}
            onClick={handleToggleChange}
            tooltip="Relative to highest concentration (on) or absolute percentage (off)"
          />
        </div>
        <div className="resource-type-filter">
          <select value={resourceTypeFilter} onChange={handleResourceTypeChange}>
            <option value="ALL">All Types</option>
            <option value="GASEOUS">Gaseous</option>
            <option value="MINERAL">Mineral</option>
            <option value="LIQUID">Liquid</option>
          </select>
        </div>
      </div>
    </div>
  );
};

export default ResourceThresholdFilter;

--- FILE: src/components/SearchField.jsx ---

import React, { useState, useContext } from 'react';
import { SearchContext } from '../contexts/SearchContext';

const SearchField = () => {
  const [notification, setNotification] = useState('');
  const {
    handleSystemSearch,
    handleCompanySearch,
    systemSearchTerm,
    companySearchTerm,
    updateSystemSearchTerm,
    updateCompanySearchTerm,
    isCompanySearch
  } = useContext(SearchContext);

  const onSearch = async (e) => {
    e.preventDefault();
    let result;
    if (isCompanySearch) {
      result = await handleCompanySearch(companySearchTerm);
    } else {
      result = handleSystemSearch(systemSearchTerm);
    }
    if (result.length === 0) {
      setNotification('No matches found');
      setTimeout(() => setNotification(''), 3000);
    } else {
      setNotification('');
    }
  };

  return (
    <div className="search-field">
      <form onSubmit={onSearch}>
        <input
          type="text"
          value={isCompanySearch ? companySearchTerm : systemSearchTerm}
          onChange={(e) => isCompanySearch ? updateCompanySearchTerm(e.target.value) : updateSystemSearchTerm(e.target.value)}
          placeholder={isCompanySearch ? "Search company code..." : "Search system, planet..."}
        />
        <button type="submit" className="search-button system-search">Search</button>
      </form>
      {notification && <div className="search-notification">{notification}</div>}
    </div>
  );
};

export default SearchField;

--- FILE: src/components/Sidebar.jsx ---

import React, { useState, useContext, useMemo } from 'react';
import { ChevronRight, ChevronLeft, Earth, Cloud, Thermometer, Gauge, Weight } from 'lucide-react';
import { GraphContext } from '../contexts/GraphContext';
import { SearchContext } from '../contexts/SearchContext';
import { SelectionContext } from '../contexts/SelectionContext';

const ResourceIcon = ({ type }) => {
  let icon = '❓';
  switch (type) {
    case 'MINERAL':
      icon = '🪨';
      break;
    case 'GASEOUS':
      icon = '💨';
      break;
    case 'LIQUID':
      icon = '💧';
      break;
    default:
      icon = '❓'; // Default case
      break;
  }
  return <span title={type}>{icon}</span>;
};

const PlanetTypeIcon = ({ isRocky }) => {
  const IconComponent = isRocky ? Earth : Cloud;
  return (
    <IconComponent
      size={18}
      color="#f7a600"
      strokeWidth={1.5}
      title={isRocky ? "Rocky Planet" : "Gas Giant"}
      style={{
        display: 'inline-block',
        verticalAlign: 'middle',
        width: '18px',
        height: '18px',
        color: '#f7a600', // Ensuring color is applied
        fill: 'none', // Ensure no fill is applied
        stroke: 'currentColor', // Use the color for stroke
      }}
    />
  );
};

const PlanetConditionIcon = ({ condition, value, ticker }) => {
  const [showTooltip, setShowTooltip] = useState(false);
  let IconComponent;
  let tooltipContent;
  let iconColor;

  const isLow = (condition, value) => {
    switch (condition) {
      case 'gravity':
        return value < 0.25;
      case 'temperature':
        return value < -25.0;
      case 'pressure':
        return value < 0.25;
      default:
        return false;
    }
  };

  switch (condition) {
    case 'gravity':
      IconComponent = Weight;
      tooltipContent = `Gravity: ${value.toFixed(2)} (${ticker})`;
      iconColor = isLow(condition, value) ? '#6f6ff7' : '#f54c4c'; // Blue for low, light red for high
      break;
    case 'temperature':
      IconComponent = Thermometer;
      tooltipContent = `Temperature: ${value.toFixed(2)}°C (${ticker})`;
      iconColor = isLow(condition, value) ? '#6f6ff7' : '#f54c4c';
      break;
    case 'pressure':
      IconComponent = Gauge;
      tooltipContent = `Pressure: ${value.toFixed(2)} atm (${ticker})`;
      iconColor = isLow(condition, value) ? '#6f6ff7' : '#f54c4c';
      break;
    default:
      return null;
  }

  return (
    <div
      className="planet-condition-icon"
      onMouseEnter={() => setShowTooltip(true)}
      onMouseLeave={() => setShowTooltip(false)}
    >
      <IconComponent
        size={16}
        color={iconColor}
        strokeWidth={1.5}
      />
      {showTooltip && (
        <div className="tooltip">
          {tooltipContent}
        </div>
      )}
    </div>
  );
};

const Sidebar = () => {
  const [isCollapsed, setIsCollapsed] = useState(window.innerWidth < 768);
  const { universeData, planetData, materials } = useContext(GraphContext);
  const { selectedSystem } = useContext(SelectionContext);
  const { searchMaterial, searchResults, isRelativeThreshold, isCompanySearch } = useContext(SearchContext);

  const toggleSidebar = () => {
    setIsCollapsed(!isCollapsed);
  };
  var materialsMap = []
  // Convert array to object for easy lookup
  if (materials && materials.length > 0) {
    materialsMap = materials.reduce((acc, material) => {
    acc[material.MaterialId] = material;
    return acc;
  }, {});
  } else {
    console.warn("Materials data is not loaded or is empty.");
  }

  const planets = selectedSystem ? planetData[selectedSystem] : null;

  // Sort planets by PlanetNaturalId
  const sortedPlanets = planets ? [...planets].sort((a, b) => a.PlanetNaturalId.localeCompare(b.PlanetNaturalId)) : null;

  const isHighlighted = (materialId, planetId) => {
    const isPlanetInSearchResults = searchResults.some(result =>
      (result.type === 'planet' && result.id === planetId) ||
      (result.type === 'material' && result.planetId === planetId) ||
      (result.type === 'company_base' && result.planetNaturalId === planetId)
    );
    const isMaterialInSearchMaterial = searchMaterial.includes(materialId);
    return (isMaterialInSearchMaterial && isPlanetInSearchResults) ||
           (isCompanySearch && isPlanetInSearchResults);
  };

  const isConditionAbnormal = (condition, value) => {
    switch (condition) {
      case 'gravity':
        return value < 0.25 || value > 2.5;
      case 'temperature':
        return value < -25.0 || value > 75.0;
      case 'pressure':
        return value < 0.25 || value > 2.0;
      default:
        return false;
    }
  };

  const getConditionTicker = (condition, value) => {
    switch (condition) {
      case 'gravity':
        return value < 0.25 ? 'MGC' : 'BL';
      case 'temperature':
        return value < -25.0 ? 'INS' : 'TSH';
      case 'pressure':
        return value < 0.25 ? 'SEA' : 'HSE';
      default:
        return '';
    }
  };

  // Calculate max concentrations for each combination of MaterialId and ResourceType across the entire universe
  const maxConcentrations = useMemo(() => {
    const maxConc = {};

    Object.values(planetData).flat().forEach(planet => {
      planet.Resources.forEach(resource => {
        const key = `${resource.MaterialId}-${resource.ResourceType}`;
        if (!maxConc[key] || resource.Factor > maxConc[key]) {
          maxConc[key] = resource.Factor;
        }
      });
    });

    return maxConc;
  }, [planetData]);

  const ConcentrationBar = ({ concentration, materialId, resourceType }) => {
    const key = `${materialId}-${resourceType}`;
    const maxConcentration = maxConcentrations[key] || concentration;
    const percentage = isRelativeThreshold
      ? (concentration / maxConcentration) * 100
      : concentration * 100;
    const hue = (percentage / 100) * 120; // 0 is red, 120 is green
    const backgroundColor = `hsl(${hue}, 100%, 50%)`;

    return (
      <div className="concentration-bar-container-sb" style={{ width: '100px', backgroundColor: '#ddd', height: '10px', marginLeft: '5px' }}>
        <div
          className="concentration-bar-sb"
          style={{
            width: `${percentage}%`,
            backgroundColor,
            height: '100%',
          }}
        />
      </div>
    );
  };

  return (
    <div className={`sidebar ${isCollapsed ? 'collapsed' : ''}`}>
      <button className="toggle-btn" onClick={toggleSidebar}>
        {isCollapsed ? <ChevronLeft /> : <ChevronRight />}
      </button>
      {!isCollapsed && (
        <div className="sidebar-content">
          <h2>{selectedSystem && universeData[selectedSystem] ? universeData[selectedSystem][0].Name : 'No System Selected'}</h2>
          {sortedPlanets && sortedPlanets.map((planet, index) => (
            <div key={planet.PlanetNaturalId} className={`planet-info-sb ${isHighlighted(null, planet.PlanetNaturalId) ? 'highlighted' : ''}`}>
              <h3>
                <PlanetTypeIcon isRocky={planet.Surface} />
                <span style={{ marginLeft: '5px' }}>
                  {planet.PlanetName}{' '}
                  (
                    <a
                      href={`https://prunplanner.org/plan/${planet.PlanetNaturalId}`}
                      className="planet-id-link"
                      target="_blank"
                      rel="noopener noreferrer"
                    >
                      {planet.PlanetNaturalId}
                    </a>
                  )
                </span>
                {isConditionAbnormal('gravity', planet.Gravity) && (
                  <PlanetConditionIcon
                    condition="gravity"
                    value={planet.Gravity}
                    ticker={getConditionTicker('gravity', planet.Gravity)}
                  />
                )}
                {isConditionAbnormal('temperature', planet.Temperature) && (
                  <PlanetConditionIcon
                    condition="temperature"
                    value={planet.Temperature}
                    ticker={getConditionTicker('temperature', planet.Temperature)}
                  />
                )}
                {isConditionAbnormal('pressure', planet.Pressure) && (
                  <PlanetConditionIcon
                    condition="pressure"
                    value={planet.Pressure}
                    ticker={getConditionTicker('pressure', planet.Pressure)}
                  />
                )}
              </h3>
              <ul>
                {planet.Resources.map((resource, idx) => {
                  const key = `${resource.MaterialId}-${resource.ResourceType}`;
                  return (
                    <li
                      key={idx}
                      className="resource-item-sb"
                      style={{
                        display: 'flex',
                        alignItems: 'center',
                        marginBottom: '5px',
                        fontWeight: isHighlighted(resource.MaterialId, planet.PlanetNaturalId) ? 'bold' : 'normal',
                        color: isHighlighted(resource.MaterialId, planet.PlanetNaturalId) ? '#4a90e2' : 'inherit',
                        backgroundColor: isHighlighted(resource.MaterialId, planet.PlanetNaturalId) ? 'rgba(74, 144, 226, 0.1)' : 'transparent',
                        padding: '2px 5px',
                        borderRadius: '3px'
                      }}
                    >
                      <ResourceIcon type={resource.ResourceType} />
                      <span style={{ marginLeft: '5px', minWidth: '50px' }}>{materialsMap[resource.MaterialId]?.Ticker || 'Unknown'}</span>
                      <ConcentrationBar
                        concentration={resource.Factor}
                        materialId={resource.MaterialId}
                        resourceType={resource.ResourceType}
                      />
                      <span className="resource-percentage">
                        {isRelativeThreshold
                          ? ((resource.Factor / maxConcentrations[key]) * 100).toFixed(2)
                          : (resource.Factor * 100).toFixed(2)}%
                      </span>
                    </li>
                  );
                })}
              </ul>
              {isCompanySearch && isHighlighted(null, planet.PlanetNaturalId) && (
                <div className="company-base-indicator">Company Base</div>
              )}
            </div>
          ))}
        </div>
      )}
    </div>
  );
};

export default Sidebar;

--- FILE: src/components/UniverseMap.css ---

/* UniverseMap.css */
#map-container {
  width: 100%;
  height: 100vh; /* Full viewport height */
  overflow: hidden;
  position: relative;
}

#map-container svg {
  width: 100%;
  height: 100%;
}

.info-panel {
  position: absolute;
  background-color: rgba(0, 0, 0, 0.8);
  color: #fff;
  padding: 15px;
  border-radius: 8px;
  pointer-events: none;
  z-index: 10;
  font-family: Arial, sans-serif;
  max-width: 400px;
  box-shadow: 0 0 10px rgba(255, 255, 255, 0.1);
}

.info-panel h3 {
  margin-top: 0;
  margin-bottom: 10px;
  font-size: 16px;
  border-bottom: 1px solid rgba(255, 255, 255, 0.3);
  padding-bottom: 5px;
}

.planet-list {
  list-style-type: none;
  padding-left: 0;
  margin-top: 5px;
}

.planet-list li {
  margin-bottom: 12px;
  font-size: 13px;
}

.planet-info {
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.planet-name-tier {
  display: flex;
  justify-content: space-between;
  align-items: center;
  width: 70%;
}

.planet-name {
  flex-grow: 1;
  margin-right: 10px;
}

.planet-tier {
  color: gold;
  white-space: nowrap;
  margin-right: 20px;
}

.facility-indicators {
  display: flex;
  align-items: center;
}

.facility-indicators span {
  margin-left: 1px;
}

.cogc-program {
  margin-bottom: 10px;
  padding-left: 10px;
}

.highlighted-planet {
  background-color: rgba(247, 166, 0, 0.2);
  border-radius: 4px;
}

.highlighted-planet .planet-name {
  font-weight: bold;
  color: #f7a600;
}

.matching-resources {
  margin-top: 5px;
  padding-top: 5px;
  border-top: 1px solid rgba(255, 255, 255, 0.2);
}

.resource-item {
  display: flex;
  align-items: center;
  margin-bottom: 5px;
  width: 100%; /* Ensure full width */
}

.resource-name {
  width: 40px;
  text-align: right;
  margin-right: 5px;
}

.concentration-bar-container {
  width: 100px;
  background-color: #ddd;
  height: 10px;
  margin: 0 5px;
}

.resource-percentage {
  width: 50px;
  text-align: right;
}

/* Media queries for smaller screen sizes */
@media (max-width: 820px) {
  .info-panel {
    max-width: 400px;
    padding: 10px;
  }

  .info-panel h3 {
    font-size: 14px;
    margin-bottom: 8px;
  }

  .planet-list li {
    font-size: 12px;
    margin-bottom: 8px;
  }

  .planet-name-tier {
    width: 100%;
    align-items: center;
  }

  .planet-name {
    margin-right: 5px;
    margin-bottom: 2px;
  }

  .planet-tier {
    margin-right: 5px;
    font-size: 10px;
  }

  .facility-indicators {
    margin-top: 4px;
  }

  .facility-indicators svg {
    width: 14px;
    height: 14px;
  }

  .cogc-program {
    font-size: 10px;
    margin-bottom: 6px;
    padding-left: 5px;
  }

  .resource-item {
    font-size: 10px;
  }

  .resource-name {
    width: 30px;
  }

  .concentration-bar-container {
    width: 70px;
    height: 8px;
  }

  .resource-percentage {
    width: 40px;
  }
}

--- FILE: src/components/UniverseMap.jsx ---

import React, { useEffect, useContext, useRef, useCallback } from 'react';
import DataPointOverlay from './DataPointOverlay';
import * as d3 from 'd3';
import { GraphContext } from '../contexts/GraphContext';
import { SelectionContext } from '../contexts/SelectionContext';
import { useCogcOverlay } from '../contexts/CogcOverlayContext';
import { addMouseEvents } from '../utils/svgUtils';
import { cogcPrograms } from '../constants/cogcPrograms';
import './UniverseMap.css';
import { SearchContext } from '../contexts/SearchContext';

const UniverseMap = React.memo(() => {
  const { graph, planetData, materials } = useContext(GraphContext);
  const { highlightSelectedSystem } = useContext(SelectionContext);
  const { overlayProgram } = useCogcOverlay();
  const { searchResults, isRelativeThreshold } = useContext(SearchContext);
  const svgRef = useRef(null);
  const graphRef = useRef(null);
  // Handle system click
  const handleSystemClick = useCallback((systemId) => {
    if (systemId === 'rect1') {
      return;
    }
    highlightSelectedSystem(systemId);
  }, [highlightSelectedSystem]);

  // Attach click events
  const attachClickEvents = useCallback((g) => {
    g.selectAll('rect').on('click', function() {
      const systemId = d3.select(this).attr('id').replace('#', '');
      handleSystemClick(systemId);
    });
  }, [handleSystemClick]);

  // Initialize D3 graph
  useEffect(() => {
    if (!graph || !graph.edges) return;

    d3.xml('PrUn_universe_map_normalized.svg').then(data => {
      const svgNode = data.documentElement;
      const container = document.getElementById('map-container');

      // Clear any existing SVG to prevent duplicates
      while (container.firstChild) {
        container.removeChild(container.firstChild);
      }

      // Append the SVG node to the container
      container.appendChild(svgNode);

      // Select the SVG element and create a group element
      const svg = d3.select(svgNode);
      const g = svg.append('g');

      // Move all children of the SVG to the group
      while (svgNode.firstChild && svgNode.firstChild !== g.node()) {
        g.node().appendChild(svgNode.firstChild);
      }

      graphRef.current = { svg, g };

      const zoom = d3.zoom()
        .scaleExtent([1, 20])
        .on('zoom', (event) => {
          g.attr('transform', event.transform);
        });

      svg.call(zoom);

      addMouseEvents(g, searchResults, materials);

      // Store references for later use
      svgRef.current = svgNode;
      graphRef.current = { svg, g };

      // Attach click events here, after the SVG is fully initialized
      attachClickEvents(g);
    });

    // Cleanup function
    return () => {
      if (svgRef.current) {
        const container = document.getElementById('map-container');
        if (container && container.contains(svgRef.current)) {
          container.removeChild(svgRef.current);
        }
      }
    };
  // eslint-disable-next-line
  }, [graph]);

  useEffect(() => {
    if (graphRef.current) {
      addMouseEvents(graphRef.current.g, searchResults, materials, isRelativeThreshold);
    }
  }, [searchResults, materials, isRelativeThreshold]);

  // Apply Cogc overlay
  const applyCogcOverlay = useCallback(() => {
    if (!graphRef.current || !overlayProgram) return;

    const { g } = graphRef.current;
    const selectedProgramValue = cogcPrograms.find(program => program.display === overlayProgram)?.value;

    g.selectAll('.cogc-overlay-rect').remove();

    g.selectAll('rect').each(function() {
      const rect = d3.select(this);
      const systemId = d3.select(this).attr('id');
      const planets = planetData[systemId];

      if (planets && planets.some(planet => {
        if (!planet.COGCPrograms || planet.COGCPrograms.length === 0) return false;
        const sortedPrograms = planet.COGCPrograms.sort((a, b) => b.StartEpochMs - a.StartEpochMs);
        const relevantProgram = sortedPrograms[1] || sortedPrograms[0];
        return relevantProgram && relevantProgram.ProgramType === selectedProgramValue;
      })) {
        rect.classed('cogc-overlay', true);
        const x = parseFloat(rect.attr('x'));
        const y = parseFloat(rect.attr('y'));
        const width = parseFloat(rect.attr('width'));
        const height = parseFloat(rect.attr('height'));
        const scaleUp = 4;
        // Create a new overlay rect
        const overlayRect = g.append('rect')
          .attr('class', 'cogc-overlay-rect')
          .attr('x', x - scaleUp/2)
          .attr('y', y - scaleUp/2)
          .attr('width', width + scaleUp)
          .attr('height', height + scaleUp)
          .attr('fill', 'none')
          .attr('stroke', '#56c7f7')
          .attr('stroke-width', '3px')
          .attr('rx', '50%')
          .attr('ry', '50%');
        rect.property('cogcOverlayRect', overlayRect);
      } else {
        rect.classed('cogc-overlay', false);
        rect.property('cogcOverlayRect', null);
      }
    });
  }, [overlayProgram, planetData]);

  // Effect to apply Cogc overlay when overlayProgram changes
  useEffect(() => {
    applyCogcOverlay();
  }, [applyCogcOverlay]);

  // Update click events when handleSystemClick changes
  useEffect(() => {
    if (graphRef.current) {
      attachClickEvents(graphRef.current.g);
    }
  }, [attachClickEvents]);

  return (
    <div id="map-container">
      <DataPointOverlay mapRef={graphRef} />
    </div>
  );
});

export default UniverseMap;

--- FILE: src/config/config.js ---

// Color palette and configuration constants
export const colors = {
  searchSystemFill: '#f7a600',
  searchSystemStroke: '#000000',
  searchSystemStrokeWidth: '1px',
  searchSystemFillLowLiquid: '#fcb6b6',
  searchSystemFillLiquid: '#ff0000',
  searchSystemFillLowGaseous: '#a2defc',
  searchSystemFillGaseous: '#009eed',
  searchSystemFillLowMineral: '#cefab9',
  searchSystemFillMineral: '#3fbf00',
  systemFill: '#f7a600',
  systemStroke: '#000000',
  pathStroke: '#f7a600',
  pathStrokeWidth: '2px',
  resetSystemFill: '#cccccc',
  resetSystemStroke: '#000000',
  resetSystemFillOpacity: 0.8,
  resetSystemStrokeWidth: '1px',
  resetPathStroke: '#6e7980',
  resetPathStrokeWidth: '1px'
};


--- FILE: src/hooks/useFetchGraphData.js ---

import { useState, useEffect } from 'react';

export const useFetchGraphData = () => {
  const [graphData, setGraphData] = useState(null);

  useEffect(() => {
    console.log('useFetchGraphData hook executed');
    fetch('graph_data.json')
      .then(response => response.json())
      .then(data => {
        console.log('Fetched Graph Data:', data);
        setGraphData(data);
      })
      .catch(error => {
        console.error('Error fetching graph data:', error);
      });
  }, []);

  return graphData;
};

--- FILE: src/hooks/useGraphState.js ---

import { useState, useCallback } from 'react';
import fetchGraphData from './useFetchGraphData';

const useGraphState = () => {
  const [graph, setGraph] = useState({ nodes: {}, edges: [] });

  const fetchGraphDataCallback = useCallback(async () => {
    const data = await useFetchGraphData();
    setGraph(data);
  }, []);

  return {
    graph,
    fetchGraphData: fetchGraphDataCallback,
  };
};

export default useGraphState;


--- FILE: src/constants/cogcPrograms.js ---

export const cogcPrograms = [
  { value: "ALL", display: "All Programs" },
  { value: null, display: "No Program" },
  { value: "ADVERTISING_RESOURCE_EXTRACTION", display: "Resource Ext." },
  { value: "ADVERTISING_CHEMISTRY", display: "Chemistry" },
  { value: "ADVERTISING_METALLURGY", display: "Metallurgy" },
  { value: "ADVERTISING_MANUFACTURING", display: "Manufacturing" },
  { value: "ADVERTISING_AGRICULTURE", display: "Agriculture" },
  { value: "ADVERTISING_FOOD_INDUSTRIES", display: "Food Industries" },
  { value: "ADVERTISING_CONSTRUCTION", display: "Construction" },
  { value: "ADVERTISING_FUEL_REFINING", display: "Fuel Refining" },
  { value: "ADVERTISING_ELECTRONICS", display: "Electronics" }
];

--- FILE: public/index.html ---

<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <link rel="icon" href="%PUBLIC_URL%/icons/icon-72x72.png" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="theme-color" content="#000000" />
    <meta
      name="description"
      content="Taiyi's Prosperous Universe Map - An interactive map for the Prosperous Universe game"
    />
    <link rel="apple-touch-icon" href="%PUBLIC_URL%/icons/icon-192x192.png" />
    <!--
      manifest.json provides metadata used when your web app is installed on a
      user's mobile device or desktop. See https://developers.google.com/web/fundamentals/web-app-manifest/
    -->
    <link rel="manifest" href="%PUBLIC_URL%/manifest.json" />
    <!--
      Notice the use of %PUBLIC_URL% in the tags above.
      It will be replaced with the URL of the `public` folder during the build.
      Only files inside the `public` folder can be referenced from the HTML.

      Unlike "/favicon.ico" or "favicon.ico", "%PUBLIC_URL%/favicon.ico" will
      work correctly both with client-side routing and a non-root public URL.
      Learn how to configure a non-root public URL by running `npm run build`.
    -->
    <title>Taiyi's Prosperous Universe Map</title>
  </head>
  <body>
    <noscript>You need to enable JavaScript to run this app.</noscript>
    <div id="root"></div>
    <!--
      This HTML file is a template.
      If you open it directly in the browser, you will see an empty page.

      You can add webfonts, meta tags, or analytics to this file.
      The build step will place the bundled scripts into the <body> tag.

      To begin the development, run `npm start` or `yarn start`.
      To create a production bundle, use `npm run build` or `yarn build`.
    -->
  </body>
</html>
